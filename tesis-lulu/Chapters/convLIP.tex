\myChapter{Convolución LIP}\label{chap:convLIP}
\minitoc\mtcskip
\vfill
\lettrine{E}{l} modelo \textsc{LIP} presenta muchas características beneficiosas en el procesamiento de imágenes naturales, como por ejemplo, procesado homogéneo en zonas con iluminación no uniforme, alta sensibilidad en zonas oscuras, robustez matemática, etc. Para aprovechar estas ventajas, algunos algoritmos tradicionales se han portado al paradigma \textsc{LIP} mediante aproximaciones \emph{ad hoc}. En muchos casos, las implementaciones de los algoritmos bajo \textsc{LIP} son tan específicas que obligan a recodificar incluso tras un cambio de parámetros, lo que ha limitado en gran medida el avance de este paradigma.\\
\noindent Una gran cantidad de algoritmos de procesamiento de imágenes utilizan la \emph{convolución} como operador principal, lo que hace que dicho operador se considere entre los más importantes dentro de este campo. Por ello, en este capítulo se presentan las bases matemáticas de un nuevo operador, \mbox{\emph{Convolución--\textsc{LIP}}}, que se propone como una de las principales aportaciones de esta Tesis Doctoral. Esta adaptación se ha diseñado para sustituir al operador tradicional \emph{convolución} bajo el modelo \textsc{LIP}, y para que, además, se puedan aplicar de manera simple y eficaz, los filtros de procesamiento de imágenes utilizando este modelo. Este nuevo operador permite implementar fácilmente una gran cantidad de algoritmos de procesamiento de imágenes. Esta aportación científica se describe matemáticamente en este capítulo, indicando rangos de funcionamiento y se presentan dos métodos diferentes para la implementación de dicho operador.
\vfill
\clearpage
\section{La convolución en el procesamiento de imágenes}
\lettrine{M}{uchos} algoritmos de procesamiento de imágenes y vídeo utilizan el operador \emph{convolución} como uno de los primeros componentes matemáticos en el proceso de obtención del resultado. Esto provoca, a su vez, que la \emph{convolución} sea, de manera generalizada, uno de los elementos principales para el desarrollo de los procedimientos de procesado de imágenes y vídeo.\\
\noindent También hay que indicar que la \emph{convolución} espacial es un operador con alto consumo computacional. Este alto consumo provoca que para muchos algoritmos de procesamiento de imágenes, el porcentaje de tiempo de cómputo consumido por la \emph{convolución} sea muy elevado, en algunos casos superior al $50\%$ del tiempo total del algoritmo. Por ello, se han realizado muchos esfuerzos por mejorar el rendimiento de este operador, tanto a nivel matemático como a nivel computacional, por ejemplo, proponiendo implementaciones paralelas eficientes.\\
\noindent Aunque en la mejora del operador \emph{convolución} no sólo debe tenerse en cuenta el aspecto del rendimiento temporal, sino también si la implementación propuesta permite realizar otras operaciones adicionales. Por ejemplo, una determinada implementación de la \emph{convolución} será mejor que la implementación básica habitual, si además de la operación \emph{convolución} tradicional es capaz de aplicar una función de transformación del espacio de trabajo. En particular, este aspecto es uno de los más beneficiosos que permite el nuevo operador que se propone en este capítulo.
\subsection{Descripción matemática de la convolución}
La \emph{convolución} es un operador matemático que aplica un determinado filtro sobre una entrada, en las que tanto la imagen como el filtro pueden ser discretos o continuos, y también unidimensionales, bidimensionales o multidimensionales. De manera habitual, el operador \emph{convolución} espacial utilizado en el ámbito del procesamiento de imágenes opera con filtros discretos unidimensionales o bidimensionales y con imágenes discretas bidimensionales, y es este tipo de operador el que se va a considerar en esta Tesis.\\
\noindent Los filtros serán, respectivamente, matrices bidimensionales o vectores unidimensionales compuestos por valores escalares discretos. A continuación, se muestra la formulación matemática de la \emph{convolución} espacial con filtros bidimensionales:\\
\begin{flalign*}
C=\convtwod (I,F) &= 
\begin{pmatrix}F(1,1)&\ldots&F(1,n_f)\\
\vdots &\ddots&\vdots\\
F(m_f,1)&\ldots&F(m_f,n_f)\end{pmatrix}
\circledast
\begin{pmatrix}
I(1,1)&\ldots&I(1,w)\\
\vdots&\ddots&\vdots\\
I(h,1)&\ldots&I(h,w)
\end{pmatrix}\\
&= \begin{pmatrix}C(1,1)&\ldots&C(1,w)\\
\vdots &\ddots&\vdots\\
C(h,1)&\ldots&C(h,w)\end{pmatrix}&
\end{flalign*}
Donde $F$ representa a un filtro bidimensional de tamaño $m_f\times n_f$ elementos e $I$ representa una imagen de tamaño $h \times w$.
\begin{equation}
C(i,j) = \sum_{m=0}^{m_f-1}\sum_{n=0}^{n_f-1}\left(F(m,n)\cdot I(i-m, j-n)\right)
\end{equation}
con $1\le i \le h$, $1 \le j \le w$.

\subsection{Convolución 2D con filtros separables}\label{sec:convolucion2d}
Si la matriz bidimensional que compone el filtro se puede construir a partir de la multiplicación matricial de dos vectores unidimensionales, se dice que dicho filtro es separable. La separación de los filtros permite que una convolución con un filtro bidimensional, se pueda realizar mediante dos convoluciones consecutivas con filtros unidimensionales. La gran mayoría de algoritmos de procesamiento de imágenes utilizan filtros que son separables. Por tanto, en esta Tesis Doctoral se va a trabajar utilizando el operador \emph{convolución} con filtros bidimensionales separables (por abreviar, \emph{convolución} 2D), realizada a partir de dos \emph{convoluciones} 1D (denominación abreviada de \emph{convolución} que usa filtros unidimensionales) consecutivas. A continuación se expone la formulación matemática que describe este tipo de \emph{convolución}:
\begin{equation}\label{eq:convolucion}
\convtwod (I,F) = \overbrace{\convoned (\underbrace{ \convoned (I,\vec{a}^T) }_{\vec{c_a}} , \vec{b})}^{\vec{c_b}}
\end{equation}
en la que $I$ representa a una imagen y $F$ es el filtro que se desea aplicar espacialmente. En este caso, el filtro $F$ es una matriz bidimensional que se puede separar en dos vectores fila unidimensionales $\vec{a}$, $\vec{b}$, tal que $F = \vec{a}^T \times \vec{b}$. Donde $\vec{a}^T$ representa la transpuesta del vector $\vec{a}$, es decir, un vector columna. Para simplificar el proceso se ha tomado que el tamaño del filtro coincide con el tamaño de la imagen, aspecto este que no afecta a la formulación matemática en absoluto, salvo por la claridad en el desarrollo.\\
\noindent La ecuación \eqref{eq:convolucion} se puede desarrollar, de manera sencilla, expandiendo sus términos. A continuación, se describe el contenido de $\vec{c_a}$, que es el resultado de la \emph{convolución} 1D de la imagen por el vector $\vec{a}^T$:
\begin{flalign*}
\vec{c_a} &= \begin{pmatrix}\vec{a}(1)\\ \vdots \\\vec{a}(m)\end{pmatrix}
\circledast
\begin{pmatrix}
I(1,1)&\ldots&I(1,n)\\
\vdots&\ddots&\vdots\\
I(m,1)&\ldots&I(m,n)
\end{pmatrix}\\
&=\Big[
  \vec{a}(m)\cdot I(1,1)+\ldots+\vec{a}(1)\cdot I(m,1), \\
& \qquad\!\vec{a}(m)\cdot I(1,2)+\ldots+\vec{a}(1)\cdot I(m,2), \ldots ,\\
& \qquad\!\vec{a}(m)\cdot I(1,n)+\ldots+\vec{a}(1)\cdot I(m,n)
\Big]\\
&= {\mathrm{vector}}_{i=0}^{n-1}\Big[ \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m\!-\!j\displaystyle)\cdot I(\scriptstyle i\!+\!1\displaystyle,\scriptstyle j\!+\!1\displaystyle)\Big] = \Big[ \vec{c_a}(1),\ldots, \vec{c_a}(n) \Big] &
\end{flalign*}
Donde $\vec{a}(i)$ representa el valor i--ésimo del vector $\vec{a}$ e $I(i,j)$ es el valor de la imagen que se encuentra en la columna j-ésima de la fila i-ésima.\\
\noindent De manera análoga, siguiendo la misma descripción anterior, se puede obtener $\vec{c_b} = \convoned(\vec{c_a},\vec{b})$, como:
\begin{flalign*}
\vec{c_b} &= \vec{b}(n)\cdot \vec{c_a}(1)+\ldots+\vec{b}(1)\cdot \vec{c_a}(n) = \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\cdot \vec{c_a}(\scriptstyle i + 1\displaystyle) \\
&= \sum\limits_{i=0}^{n-1}\Big(\vec{b}(\scriptstyle n - i\displaystyle)\cdot\big(\sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\cdot I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)\big)\Big)
\end{flalign*}
Con lo que se obtiene la fórmula conocida de la \emph{convolución} 2D a partir de dos \emph{convoluciones} 1D:
\begin{equation}
\convtwod(I,F) = \sum\limits_{i=0}^{n-1}\vec{b}(\scriptstyle n - i\displaystyle)\cdot\left(\sum\limits_{j=0}^{m-1}\vec{a}(\scriptstyle m - j\displaystyle)\cdot I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)\right) \label{eq:convNormal}
\end{equation}
\noindent Esta formulación de la \emph{convolución} 2D con filtros separables permite reducir la complejidad de los cálculos frente a la \emph{convolución} 2D con filtros bidimensionales, ya que se utilizan un menor número de iteraciones para calcular el mismo resultado. Esto reduce la complejidad computacional de $O(n^4)$ en la implementación de la \emph{convolución} 2D con filtros bidimensionales a $2\cdot O(n^3)$ para la \emph{convolución} 2D con filtros separables, por lo que, siempre que sea posible es preferible utilizar este último método.
%\clearpage
\section{Convolución LIP 2D con filtros separables}\label{sec:lipConvolution}
\lettrine{E}{n} esta sección se expondrá toda la formulación matemática necesaria para calcular la versión \textsc{LIP} de la \emph{convolución} de la Ec. (\ref{eq:convNormal}), a la que se llamará  \mbox{\emph{Convolución--\textsc{LIP}} \citep{palomares06,palomares05a}}. Como se ha comentado en la Sec. \ref{sec:introLIP}, el paradigma \textsc{LIP} permite adaptar las fórmulas del procesamiento clásico de imágenes, de dos maneras diferentes: mediante un método ``directo'' o mediante un método basado en una ``transformada''. En este caso, se obtendrá la \mbox{\emph{Convolución--\textsc{LIP}}} mediante el método ``directo'', en la que se tendrá una fórmula con operadores modificados \textsc{LIP} y con la imagen en \emph{tonos de gris}. Una vez se tenga una fórmula que utilice operadores \textsc{LIP}, se desarrollará esa fórmula para que en la misma sólo se encuentren operadores tradicionales.
\subsection{Desarrollo matemático de la Convolución LIP 2D}
Así pues, tomando como inicio \eqref{eq:convNormal}, se aplica el mecanismo ``directo'' del paradigma \textsc{LIP}, sustituyendo los operadores tradicionales por los operadores modificados \textsc{LIP} ($\LIPsumSmall$ , $\LIPtimes$) y utilizando la imagen en \emph{tono de gris}, $\widehat{I}$. Quedando la siguiente ecuación:
\begin{equation}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) = \LIPsum{i=0}{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\LIPtimes \Bigg(\ \LIPsum{j=0}{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\LIPtimes \ \widehat{I}(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)\Bigg)
\end{equation}
\noindent Para utilizar sólo operadores tradicionales, se aplica en ambas partes la transformada isomórfica, \eqref{eq:isomorTransf}. Como los valores de los vectores filtro son valores escalares, no es necesario aplicarles ninguna función de transformación, por tanto, la transformada isomórfica se aplica únicamente a la imagen.
\begin{equation}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \!\sum\limits_{i=0}^{n-1} \!\vec{b}(\scriptstyle n - i\displaystyle) \!\cdot\! \left( \sum\limits_{j=0}^{m-1}\!\vec{a}(\scriptstyle m  - j\displaystyle)\!\cdot\! \varphi\big(\widehat{I}(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle\!) \big)\! \right) \label{eq:convLIP-directa}
\end{equation}
\noindent Tomando \eqref{eq:convLIP-directa}, se desarrolla la función transformada isomórfica, se renombra \mbox{$\big(M-\widehat{I}(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)\big)$} como \mbox{$I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)$} y se continúa operando:
\begin{flalign}
& \varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \nonumber\\
&= \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\!\cdot\! \left( \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\!\cdot\! \left( - M \cdot \ln  \left( \frac{ M - \widehat{I} (\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)}{M}\! \right) \!\right) \!\right) & \nonumber\\
&= -M\cdot\sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\cdot \left(\sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\cdot \left(\ln \left(\frac{I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)}{M}\right)\right)\right) & \nonumber
\end{flalign}
\begin{flalign}
&= -M \cdot \sum\limits_{i=0}^{n-1} \vec{b} ( \scriptstyle n - i\displaystyle ) \cdot \Bigg[ \left( \sum\limits_{j=0}^{m-1} \vec{a} ( \scriptstyle m - j \displaystyle) \cdot \ln \left( I( \scriptstyle i + 1 \displaystyle, \scriptstyle j + 1\displaystyle) \right) \right) & \nonumber\\
&\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad - \left( \sum\limits_{j=0}^{m-1} \vec{a} ( \scriptstyle m - j \displaystyle ) \cdot \ln (M) \right)\Bigg] & \nonumber\\
&= -M \cdot \Bigg[\!\sum\limits_{i=0}^{n-1}\! \vec{b}(\scriptstyle n - i\displaystyle)\cdot\!\left(\! \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle) \cdot\ln \left( I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle) \right) \right)& \nonumber\\
&\qquad\qquad\qquad\qquad - \Bigg(\ln(M) \cdot \bigg(\sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle) \cdot \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle) \bigg) \Bigg) \Bigg]&
\end{flalign}
%\begin{align}
%&\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \nonumber\\
%=& \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\!\cdot\! \left( \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\!\cdot\! \left( - M \cdot \ln  \left( \frac{ M - \widehat{I} (\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)}{M}\! \right) \!\right) \!\right) = \nonumber \\
%=&-M\cdot\sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle)\cdot \left(\sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle)\cdot \left(\ln \left(\frac{I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)}{M}\right)\right)\right)  = \nonumber \\
%= & -M \! \cdot \! \sum\limits_{i=0}^{n-1} \! \vec{b} ( \scriptstyle n \! -\! i\displaystyle )\! \cdot \! \Bigg[\! \left(\! \sum\limits_{j=0}^{m-1} \! \vec{a} ( \scriptstyle m \! -\! j \displaystyle)\! \cdot \! \ln \! \left( \! I( \scriptstyle i \! +\! 1 \displaystyle, \scriptstyle j \! + \! 1\displaystyle) \! \right) \! \right) \! - \! \left( \! \sum\limits_{j=0}^{m-1} \! \vec{a} ( \scriptstyle m \! - \! j \displaystyle ) \! \cdot \! \ln (M) \! \right)\! \Bigg] = \nonumber
%\end{align}
%\vspace{-1em}
%\begin{eqnarray}
%= -M \cdot \Bigg[\!\sum\limits_{i=0}^{n-1}\! \vec{b}(\scriptstyle n - i\displaystyle)\cdot\!\left(\! \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle) \cdot\ln \left( I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle) \right) \right) -&\nonumber \\
%- \Bigg(\ln(M) \cdot \bigg(\sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m - j\displaystyle) \cdot \sum\limits_{i=0}^{n-1} & \vec{b}(\scriptstyle n - i\displaystyle) \bigg) \Bigg) \Bigg] \nonumber\\
%\end{eqnarray}
\noindent Para simplificar la ecuación anterior, se puede definir la siguiente constante: 
\begin{equation}
K\!=\!\left(\!\sum\limits_{j=0}^{m-1}\!\vec{a}(\scriptstyle m - j\displaystyle)\!\cdot\!\sum\limits_{i=0}^{n-1}\!\vec{b}(\scriptstyle n - i\displaystyle)\!\right)\label{eq:K}
\end{equation}
\noindent Gracias a la que se obtiene \eqref{eq:convlipB}.
\begin{multline}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \\
-M \! \cdot \! \Bigg[ \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n \! -\!  i\displaystyle)\cdot \left( \sum\limits_{j=0}^{m-1} \vec{a}(\scriptstyle m \! - \! j\displaystyle) \cdot\ln  \left(I(\scriptstyle i\! +\! 1\displaystyle,\scriptstyle j\! +\! 1\displaystyle) \right)\!\right) - K\cdot \ln (M) \Bigg] \label{eq:convlipB}
\end{multline}
\subsection{Convolución LIP Generalizada Directa: DGLIP--Conv}
En la sección anterior se ha descrito el operador \emph{Convolución--\textsc{LIP}} desde un punto de vista estrictamente matemático. En esta sección se describe una implementación específica del nuevo operador propuesto, que se ha llamado \definicion[-2em]{DGLIP--Conv}{Del inglés, \textsc{Direct General LIP--Convolution}, Convolución--LIP Generalizada Directa}. Se ha denominado este método como \emph{Directo} puesto que se usa el mecanismo directo de aplicación de \textsc{LIP}: uso de imágenes ``originales'' con operadores especiales.\\
\noindent Tomando como base \eqref{eq:convlipB} y sabiendo que $a\cdot\ln x = \ln x^a$, se puede obtener la siguiente reformulación:
\begin{multline}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \\
-M \cdot\left[ \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle) \cdot \left( \sum\limits_{j=0}^{m-1}\ln  \left( I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)^{ \vec{a}(\scriptstyle m - j\displaystyle)} \right) \right) - K\cdot\ln (M)\right]
\end{multline}
\noindent Como se sabe, $\sum\limits_{i}\left(\ln x_i\right) = \ln \left(\prod\limits_{i} x_i\right)$, y por tanto:
\begin{multline}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \\
-M \cdot\left[ \sum\limits_{i=0}^{n-1} \vec{b}(\scriptstyle n - i\displaystyle) \cdot \ln\left( \prod\limits_{j=0}^{m-1} I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)^{ \vec{a}(\scriptstyle m - j\displaystyle)} \right) - K\cdot\ln (M)\right] \nonumber
\end{multline}
\noindent Se vuelve a aplicar a la fórmula el hecho de que $a\cdot\ln x = \ln x^a$, obteniéndose:
\begin{multline}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \\
-M \cdot\left[ \sum\limits_{i=0}^{n-1} \ln\left(\left( \prod\limits_{j=0}^{m-1} I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle)^{ \vec{a}(\scriptstyle m - j\displaystyle)} \right)^{\vec{b}(\scriptstyle n - i\displaystyle)} \right) - K\cdot\ln (M)\right] \nonumber
\end{multline}
Finalmente, se reordena la fórmula retirando el valor negativo del factor $M$ que multiplica a toda la fórmula y se obtiene:
\begin{multline}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = \\
M \cdot\left[K\cdot\ln (M) - \ln\left(\prod\limits_{i=0}^{n-1} \left( \prod\limits_{j=0}^{m-1}  I(\scriptstyle  i + 1\displaystyle,\scriptstyle j + 1\displaystyle)^{ \vec{a}(\scriptstyle m - j\displaystyle)} \right)^{\vec{b}(\scriptstyle n - i\displaystyle)} \right)\right] \label{eq:prodLIP}
\end{multline}
Por último, aplicando la transformada isomórfica inversa \eqref{eq:inverseIsomorTransf} a \eqref{eq:prodLIP}, se obtiene:
\begin{multline}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)=\varphi^{-1}\bigg (\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big)\bigg) = \\
M\cdot\left(1-\frac{\prod\limits_{i=0}^{n-1}\prod\limits_{j=0}^{m-1}  \left(I(\scriptstyle i + 1\displaystyle,\scriptstyle j + 1\displaystyle) ^{ \vec{a}(m - j)}  \right)^ {\vec{b}(n - i)}} {{M}^{K}}\right) \label{eq:prodLIPgt}
\end{multline}
\subsection{Convolución LIP Generalizada Rápida: FGLIP--Conv}
La formulación que se ha presentado en la sección anterior (\textsc{DGLIP--Conv}) utiliza los operadores división y exponenciación, que son computacionalmente costosos. Para evitar el uso de estos operadores, se ha buscado otra formulación alternativa a la presentada anteriormente que utilice operaciones menos costosas. Esta nueva formulación sigue otra aproximación diferente para el procesado \textsc{LIP} (es decir, aplica los operadores usuales a imágenes ``transformadas''). Con esta nueva formulación, además de obtenerse los mismos resultados que con \textsc{DGLIP--Conv}, se reduce el tiempo necesario para calcular el resultado, ya que se usan operadores computacionalmente más simples. Por este motivo a la convolución obtenida mediante este método se la ha denominado \emph{Rápida}. Por tanto, para utilizar una nomenclatura análoga a la del método propuesto con anterioriedad, este método se ha llamado \definicion[-4em]{FGLIP--Conv}{Del inglés, \textsc{Fast General LIP--Convolution},\\Convolución--LIP Generalizada Rápida}.\\
\noindent Utilizando $K$, definida en \eqref{eq:K}, se puede re--escribir la ecuación (\ref{eq:convlipB}) como:
\begin{equation}
\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big) = M \cdot\left(K\cdot\ln (M) - \convoned\bigg(\convoned\big(\ln I, \vec{a}^T\big),\vec{b}\bigg)\right)\label{eq:convlipC}
\end{equation}
Análogamente, si se aplica la transformación isomórfica inversa \eqref{eq:inverseIsomorTransf} sobre \ref{eq:convlipC}, se puede obtener:
\begin{multline}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)=\varphi^{-1} \bigg(\varphi\big(\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\big)\bigg) = \\
M\cdot\bigg(1-e^{\convoned\big(\convoned(\ln I, \vec{a}^T),\vec{b}\big)-K\cdot\ln (M)}\bigg) \label{eq:convLIPgt}
\end{multline}
\section{Rango de funcionamiento de la Convolución LIP}
\lettrine{C}{omo} cualquier operador \textsc{LIP} (excepto la resta \textsc{LIP} y la multiplicación \textsc{LIP} con valores escalares negativos) el resultado de la \mbox{\emph{Convolución--\textsc{LIP}}} se restringe al intervalo $(0,M)$.\\
\noindent Con las siguientes operaciones matemáticas, se demuestra que la aplicación del operador \mbox{\emph{Convolución--\textsc{LIP}}} genera resultados dentro del rango de operación de \textsc{LIP} y por tanto, estos resultados pueden ser utilizados como entrada de nuevos operadores \textsc{LIP}. Es decir, en los siguientes apartados se demostrará la siguiente afirmación matemática:
\begin{equation*}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) \in (0,M) \subseteq \mathbb{R}
\end{equation*}
\subsection{Límite inferior del rango}
Primero se demuestra que la aplicación del operador \mbox{\emph{Convolución--\textsc{LIP}}} proporciona resultados que, en todo caso, son siempre estrictamente positivos. Para confirmarlo, se utilizará la \emph{reducción al absurdo}. Para lo cual, se niega la afirmación que se desea demostrar y se opera:
\begin{equation*}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) \not> 0 \Rightarrow
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)\le 0
\end{equation*}
\begin{equation*}
M\cdot\left(1-\frac{\prod\limits_{i=0}^{n-1}\left(\prod\limits_{j=0}^{m-1} I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)}}{M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}}\right) \le 0
\end{equation*}
\begin{align*}
\frac{\prod\limits_{i=0}^{n-1}\left(\prod\limits_{j=0}^{m-1} I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)}}{M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}} &\ge 1\\
\prod\limits_{i=0}^{n-1}\left(\prod\limits_{j=0}^{m-1} I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)} &\ge M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}\\
\prod\limits_{i=0}^{n-1}\left(\prod\limits_{j=0}^{m-1} I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)} &\ge \prod\limits_{i=0}^{n-1}\left({\prod\limits_{j=0}^{m-1} M^{\vec{a}(m-j)}}\right)^{\vec{b}(n-i)}
\end{align*}
\noindent Lo que implicaría que:
\begin{equation*}
\qquad\exists (x,y) : I(x,y) \ge M
\end{equation*}
\noindent Sin embargo, esto es imposible ya que, por definición, $I\in (0,M)\subseteq \mathbb{R}$. Con lo cual, se puede afirmar con total seguridad que la hipótesis de partida es falsa:
\begin{align}
\qquad\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)&\not\le 0 \nonumber\\
\intertext{y por tanto, queda demostrado que:}
\qquad\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)&> 0 \label{eq:limiteInferior}
\end{align}
\subsection{Límite superior del rango}
De manera análoga, también se demostrará mediante \emph{reducción al absurdo} que todos los resultados deben ser estrictamente menores que $M$.
\begin{equation*}
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) \not< M \Rightarrow
\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) \ge M
\end{equation*}
\begin{align*}
M\cdot\left(1-\frac{\prod\limits_{i=0}^{n-1}\prod\limits_{j=0}^{m-1} \left(I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)}}{M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}}\right) &\ge M \\
1-\frac{\prod\limits_{i=0}^{n-1}\prod\limits_{j=0}^{m-1} \left(I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)}}{M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}} &\ge 1\\
\frac{\prod\limits_{i=0}^{n-1}\prod\limits_{j=0}^{m-1} \left(I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)}}{M^{\sum\limits_{j=0}^{m-1} \vec{a}( m-j)\cdot\sum\limits_{i=0}^{n-1} \vec{b}(n-i)}} &\le 0 \\
\prod\limits_{i=0}^{n-1}\prod\limits_{j=0}^{m-1} \left(I(i+1,j+1)^{\vec{a}(m-j)}\right)^{\vec{b}(n-i)} &\le 0
\end{align*}
\noindent Lo que implicaría que:
\begin{equation*}
\qquad\exists (x,y) : I(x,y) \le 0
\end{equation*}
\noindent Aspecto que es imposible ya que, por definición, $I\in (0,M)\subseteq \mathbb{R}$. Esto implica que la hipótesis de partida es falsa:
\begin{align}
\qquad\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)&\not\ge 0 \nonumber\\
\intertext{y por tanto, queda demostrado que:}
\qquad\convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F)&< M \label{eq:limiteSuperior}
\end{align}
\subsection{Límite inferior y superior del rango}
Unificando \eqref{eq:limiteInferior} y \eqref{eq:limiteSuperior}, se obtiene:
\begin{equation*}
0 < \convtwod_{\scriptscriptstyle\mathrm{LIP}\displaystyle}(\widehat{I},F) < M
\end{equation*}
\noindent Lo que demuestra que el rango de trabajo del operador \mbox{\emph{Convolución--\textsc{LIP}}} es equivalente al de las imágenes \emph{tonos de gris}, con las que trabaja \textsc{LIP}. Por tanto, siempre y cuando el filtro esté compuesto por números reales y la imagen sea de \emph{tonos de gris}, este operador no va a producir resultados ``fuera de rango'' en ningún caso.
\section{Comparativas de rendimiento}
\lettrine{P}{ara} comprobar que, en las mismas condiciones, \textsc{FGLIP--Conv} es más rápido que \textsc{DGLIP--Conv}, se han realizado varios experimentos. Todos los experimentos se han aplicado sobre una imagen de tamaño $1024 \times 1024$ píxeles. Sobre esta imagen se han ido aplicando filtros de distintos tamaños, variando desde 3 hasta 515 elementos de longitud. Como para estos experimentos lo que se pretende estimar es el tiempo de cómputo, los resultados visuales no son necesarios, y por tanto, el contenido de los filtros es irrelevante. Tan sólo tiene influencia en el tiempo de procesamiento el tamaño de los filtros y no su contenido. El experimento muestra la comparación de tiempos de procesamiento para las dos implementaciones (\textsc{DGLIP--Conv} y \textsc{FGLIP--Conv}) con distintos tamaños de filtro. La \emph{convolución} ha sido aplicada mediante dos filtros vector, el primero para la \emph{convolución} horizontal y el segundo para la \emph{convolución} vertical. Los resultados temporales de este experimento se muestran en la Fig. \ref{fig:fg-dg}, mientras que en la Fig. \ref{fig:speedup-fg-dg} se muestra la evolución de la ganancia de velocidad de \textsc{FGLIP--Conv} con respecto a \textsc{DGLIP--Conv}.\\
\noindent Este experimento se ha ejecutado sobre la plataforma Matlab 7.6.0 (R2008a) bajo Linux 2.6.29 (Fedora 10) en un computador Centrino 2 Duo a 2.2 Ghz con doble núcleo de ejecución, aunque Matlab está configurado para hacer uso de un único núcleo. Tanto para \textsc{FGLIP--Conv} como para \textsc{DGLIP--Conv} se ha implementado la función minimizando el número de bucles y maximizando el número de operaciones ejecutadas sobre matrices frente a las ejecuciones frente a escalares, tal y como recomienda Matlab para optimizar el rendimiento de los programas en su plataforma. Adicionalmente, las dos implementaciones se han compilado para acelerar su ejecución. Esta optimización mejora el tiempo de proceso al eliminar la necesidad de compilación de las instrucciones cíclicas de los bucles.\\
\noindent Por otra parte, como \textsc{FGLIP--Conv} utiliza la función \emph{convolución} estándar, este operador se puede ejecutar utilizando la función \emph{convolución} optimizada que proporciona Matlab en su librería de imágenes en lugar de realizar los cálculos explícitamente. Por ello, se ha construido una versión optimizada de \emph{FGLIP-Conv}, que se ha denominado \textsc{FGLIP-Conv Optim.}, en la que se hace uso de la función \texttt{imfilter} de Matlab para implementar la \emph{convolución}. A pesar de que esta implementación está catalogada cómo \emph{Optimizada}, según la documentación de Matlab, la función \texttt{imfilter} no está optimizada para utilizar las extensiones de Intel para los tipos de datos utilizados en los experimentos. Por tanto, otras implementaciones de \texttt{imfilter} mejoradas podrían proporcionar resultados de tiempos de ejecución aún mejores.


\pgfplotstableread{tiempo.csv}\tabla
\begin{SCfigure}[][!t]
\begin{tikzpicture}
%   \pgfplotsset{
%     every x tick label/.style={yshift=-1.5em,xshift=0pt,rotate=45},
%     every axis x label/.style={at={(0.5,-0.15)},below,yshift=-15pt},
%     every axis y label/.style={at={(0.05,0.5)},xshift=-35pt,rotate=90}
%   }
 \begin{axis}[
    ymin=0,
    ymax=70,
    width=26pc,
    xlabel=Tamaño filtro,
    ylabel=Tiempo Procesamiento (segs.),
    axis x line=bottom,
    axis y line=left,
    legend style = {
      overlay,
      at={(0.4,1)},
      anchor=north
    },
  ] 

  \addplot[colorCorporativoMedio,thick,dotted] plot table[x=filtro,y=tiempoConv,header=false] from \tabla;
  \addplot[colorCorporativo,thick,dashed] plot table[x=filtro,y=tiempoProd,header=false] from \tabla;
  \addplot[colorCorporativoOscuro,thick] plot table[x=filtro,y=tiempoConvOpt,header=false] from \tabla;
  \legend{\textsc{FGLIP--Conv},\textsc{DGLIP--Conv},\textsc{FGLIP--Conv Optim.}}
 \end{axis}
\end{tikzpicture}
\caption[Comparativa \textsc{FGLIP--Conv} vs. \textsc{DGLIP--Conv}]{Comparativa de tiempos de \textsc{FGLIP--Conv} y \textsc{DGLIP--Conv} para distintos tamaños de filtros sobre una imagen de $1024 \times 1024$ píxeles.}\label{fig:fg-dg}
\end{SCfigure}

\pgfplotstableread{speedup.csv}\tabla
\begin{SCfigure}[][!t]
\begin{tikzpicture}
%   \pgfplotsset{
%     every x tick label/.style={yshift=-1.5em,xshift=0pt,rotate=45},
%     every axis x label/.style={at={(0.5,-0.15)},below,yshift=-15pt},
%     every axis y label/.style={at={(0.05,0.5)},xshift=-35pt,rotate=90}
%   }
 \begin{axis}[
    ymin=0,
    ymax=40,
    width=26pc,
    xlabel=Tamaño filtro,
    ylabel=Tiempo Procesamiento (segs.),
    axis x line=bottom,
    axis y line=left,
    legend style = {
      overlay,
      at={(0.4,1)},
      anchor=north
    },
  ] 

  \addplot[colorCorporativo,thick] plot table[x=filtro,y=speedupConv,header=false] from \tabla;
  \addplot[colorCorporativoOscuro,thick,dotted] plot table[x=filtro,y=speedupConvOpt,header=false] from \tabla;
  \legend{Speedup FGLIP--Conv,Speedup FGLIP--Conv Optim.}
 \end{axis}
\end{tikzpicture}
\caption[Speedup \textsc{FGLIP--Conv} vs. \textsc{DGLIP--Conv}]{Ganancia de velocidad de \textsc{FGLIP--Conv}/\textsc{FGLIP--Conv Optim.} frente a \textsc{DGLIP--Conv} para distintos tamaños de filtros sobre la misma imagen de $1024 \times 1024$ píxeles.}\label{fig:speedup-fg-dg}
\end{SCfigure}

% \begin{SCfigure}[][!t]
% \includegraphics[width=26pc]{gfx/fg-dg}\caption[Comparativa FGLIP-Conv vs. DGLIP-Conv]{Comparativa de tiempos de FGLIP-Conv y DGLIP-Conv para distintos tamaños de filtros sobre una imagen de $1024 \times 1024$ píxeles.}\label{fig:fg-dg}
% \end{SCfigure}
% \begin{SCfigure}[][!t]
% \includegraphics[width=26pc]{gfx/speedup-fg-dg}\caption[Speedup FGLIP-Conv vs. DGLIP-Conv]{Ganancia de velocidad de FGLIP-Conv frente a DGLIP-Conv para distintos tamaños de filtros sobre la misma imagen de $1024 \times 1024$ píxeles.}\label{fig:speedup-fg-dg}
% \end{SCfigure}

\noindent Como se puede observar en la Fig. \ref{fig:fg-dg}, para todos los tamaños de filtros, \textsc{FGLIP--Conv} es mucho más rápido que \textsc{DGLIP--Conv}. También se puede apreciar en dicha gráfica que la versión optimizada, \textsc{FGLIP--Conv Optim.} es mucho más rápida que las otras dos implementaciones.\\
\noindent En la Fig. \ref{fig:speedup-fg-dg}, se muestra la ganancia de velocidad de \textsc{FGLIP--Conv} frente a \textsc{DGLIP--Conv}. La ganancia de la versión no optimizada, \textsc{FGLIP--Conv}, se encuentra en torno al $2\%$ de media. El aumento de la ganancia de velocidad es mucho mayor cuando se utiliza la versión \emph{Optimizada}, estando siempre por encima del $10\%$ y llegando a picos del $37\%$, aunque este rendimiento va degradándose poco a poco conforme aumenta el tamaño del filtro. Por el contrario, \textsc{FGLIP--Conv} presenta un aumento suave pero progresivo en la ganancia de velocidad con respecto a los tiempos de \textsc{DGLIP--Conv}.
\subsection{Coste computacional por operador}
Para una misma ejecución particular, se ha realizado un perfilado (\emph{profiling}) de cada línea de código para cada una de las dos implementaciones descritas, obteniéndose los resultados que se muestran en la Tab. \ref{tab:profiling}. En ella, se puede observar cómo para la implementación de \textsc{DGLIP--Conv}, el tiempo empleado en la exponenciación es prácticamente igual a la suma del tiempo de todos los operadores utilizados en \textsc{FGLIP--Conv}. Esto demuestra que el coste computacional debido a los operadores es mucho mayor en \textsc{DGLIP--Conv}

\begin{SCtable}[][h]
\begin{tabular}{lcc}
\rowcolor{colorCorporativoSuave}
 Implementación				& Operador		& Tiempo \\
\hline \hline
\rowcolor{colorCorporativoMasSuave}
\cellcolor{colorCorporativoMasSuave}	& Multiplicación 	& 12.40  \\
\rowcolor{colorCorporativoSuave}
\multirow{-2}{*}{\cellcolor{colorCorporativoMasSuave}\textsc{FGLIP--Conv}} & Suma           	& 13.82  \\
\hline
\rowcolor{colorCorporativoMasSuave}
\cellcolor{colorCorporativoSuave}		& Multiplicación 	& 15.77  \\
\rowcolor{colorCorporativoSuave}
\multirow{-2}{*}{\cellcolor{colorCorporativoSuave}\textsc{DGLIP--Conv}}& Exponenciación 	& 22.07  \\
\hline
\end{tabular}\caption{Coste computacional por operador.}\label{tab:profiling}
\end{SCtable}
\section{Conclusiones}
\lettrine{E}{ste} capítulo, en el que se ha presentado toda la formulación matemática para el desarrollo del operador \emph{Convolución--\textsc{LIP}}, constituye el núcleo principal de esta Tesis Doctoral. Este operador permite, de manera sencilla y homogénea, adaptar una gran cantidad de algoritmos de procesamiento de imágenes y vídeo al paradima \textsc{LIP}.\\ 
\noindent Como resumen se muestran a continuación las principales aportaciones científicas obtenidas a partir de la investigación desarrollada en este capítulo:
\begin{itemize}
\item \emph{Convolución--\textsc{LIP}}: Se ha propuesto este nuevo operador diseñado matemáticamente utilizando la fortaleza y robustez que proporciona la estructura algebraica del paradigma \textsc{LIP}. Este diseño matemático ha permitido construir dos implementaciones diferentes:
    \begin{aenumerate}
    \item \textsc{DGLIP--Conv}: Esta implementación se obtiene a través del método ``directo'', utilizando las imágenes originales sin transformar y un conjunto de operadores matemáticos modificados. Tras operar matemáticamente se consigue una fórmula que utiliza multiplicaciones y exponenciaciones.
    \item \textsc{FGLIP--Conv}: Parte del método ``transformado'', que utiliza las imágenes aplicándoles una función de transformación y los operadores matemáticos clásicos, multiplicación y suma.
    \end{aenumerate}
\end{itemize}

\noindent Hay que indicar que ambas implementaciones son equivalentes en términos de resultados, gracias a lo cual se tienen dos mecanismos diferentes para aplicar uno de los operadores más extendidos en el procesamiento de imágenes, como es la \emph{convolución} bajo un modelo \textsc{LIP}. Éste posee unos beneficios muy importantes al trabajar con imágenes: coherencia de las operaciones con leyes físicas y psico--físicas, todas las operaciones \textsc{LIP} se mantienen dentro del rango de trabajo, los algoritmos presentan una cierta inmunidad ante efectos de iluminación no homogénea y muestran una mayor sensibilidad en zonas oscuras. A pesar de la equivalencia de las implementaciones, unos experimentos han mostrado que la implementación \textsc{FGLIP--Conv} calcula la \emph{Convolución--\textsc{LIP}} de manera más rápida que la implementación \textsc{DGLIP--Conv}.\\ 
\noindent La \emph{convolución} es un operador que suele estar implementado y optimizado en diferentes arquitecturas de computación, lo cual proporciona un mayor rendimiento que las implementaciones estríctamente software de dicho operador. Gracias a que \textsc{FGLIP--Conv} permite utilizar la \emph{convolución} estándar, se ha mostrado que es posible construir dicho operador haciendo uso de la \emph{convolución} optimizada presente en la mayoría de sistemas de computación, con un rendimiento aún más eficiente que la versión que implementa la \emph{convolución} a partir de sus operadores básicos.\\
\noindent En este capítulo se ha demostrado que el nuevo operador \emph{Convolución--\textsc{LIP}} proporciona resultados que se encuentran siempre dentro del rango $(0,M)$, independientemente de los valores del filtro que se aplique. Esto tiene unas connotaciones muy importantes, al conocerse de antemano que la imagen resultante tras aplicar \emph{Convolución--\textsc{LIP}} contendrá valores dentro de los rangos de visibilidad definidos. Así pues, no será necesario realizar comprobaciones de rangos de cada píxel, ni normalizaciones o reajustes de rangos, muy habituales al aplicar muchos algoritmos en otros modelos. Todo ello significará una reducción del tiempo de cómputo necesario, además de todas las ventajas que ofrece el modelo \textsc{LIP} para la aplicación de algoritmos de procesamiento de imágenes y vídeo.

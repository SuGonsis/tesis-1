\myChapter{Aplicaciones Convolución LIP}\label{chap:aplicacionesConvLIP}
\minitoc\mtcskip
\vfill
\lettrine{P}{ara} mostrar la aplicabilidad de la \mbox{\emph{Convolución--\textsc{LIP}}} se mostrarán una serie de experimentos con diversas técnicas habituales y bien conocidas en la literatura científica tradicional, adaptadas al paradigma \textsc{LIP}. Se han realizado experimentos con algoritmos de extracción de bordes y otros algoritmos de filtrado paso baja. Se han realizado experimentos con todos los algoritmos seleccionados en el Cap. \ref{chap:criterios}. Se comienza con un algoritmo ya implementado en \textsc{LIP}, el método \emph{LIP--Sobel}. Éste muestra que se obtienen los mismos resultados implementando el algoritmo con el método original y utilizando el mecanismo de \mbox{\emph{Convolución--\textsc{LIP}}}, implementada ésta mediante cualquiera de las dos versiones (\mbox{\textsc{DGLIP--Conv}} o \mbox{\textsc{FGLIP--Conv}}). Tras este primer experimento, se realizan experimentos con filtros de emborronamiento para la reducción del ruido, basados en un filtrado \emph{media} y en un filtrado gaussiano. Se continuará con experimentos con filtros de extracción de bordes, el \emph{Laplaciano de Gaussianas} y el método de \emph{Canny}. Para finalizar el capítulo se muestran las comparativas de tiempos de cómputo y las ganancias de velocidad, en las que se puede ver que \mbox{\textsc{FGLIP--Conv}} es la implementación más rápida para todos los algoritmos que se diseñen bajo el modelo \textsc{LIP}. 
\clearpage
\section{LIP--Sobel}\label{sec:lipSobel}
\lettrine{I}{nicialmente}, se va a mostrar que los algoritmos diseñados utilizando cualquiera de las dos implementaciones del operador \emph{Convolución--\textsc{LIP}} (\mbox{\textsc{DGLIP--Conv}} o \mbox{\textsc{FGLIP--Conv}}), definidas en el Cap. \ref{chap:convLIP},  producen el mismo resultado que los algoritmos previamente diseñados por otros autores siguiendo la metodología \textsc{LIP}. Para ello, la comparación se realizará con un método llamado \emph{LIP--Sobel}, propuesto inicialmente por \person{Deng y Pinoli} \citep{deng98}. Este método es la reformulación del método de extracción de bordes de \emph{Sobel} siguiendo el modelo \textsc{LIP}. Los autores diseñaron unas fórmulas adaptadas a \textsc{LIP}, mediante un proceso totalmente \mbox{\emph{off--line}}, a partir de los filtros habituales de \emph{Sobel}, ya que los valores de los filtros que iban a aplicar eran constantes conocidas y fijadas previamente. Estas fórmulas diseñadas son específicas para este proceso en particular y no puede exportarse a otras aplicaciones o algoritmos, por lo tanto se puede afirmar que no es un proceso general, sino específico para ese método. Sin embargo, es fácilmente deducible que la metodología sí es generalizable a otros filtros, siempre y cuando los valores de dichos filtros sean constantes y conocidos \apriori.
\subsection{Formulación}
Ya que el filtro de \emph{convolución} es suficientemente pequeño se puede asumir que la \emph{iluminación} dentro de un área tan reducida es constante. Esto ha producido un método que se comporta de manera casi invariante ante los cambios de iluminación y proporciona una respuesta mucho más satisfactoria para la detección de los contornos de objetos en sombras que el método \emph{Sobel} original (es decir, sin \textsc{LIP}). Este nuevo método detecta bordes tanto en zonas bien iluminadas como en las pobremente iluminadas o en las sobreiluminadas.\\
\noindent Sea un área o un entorno de \emph{tonos de gris}, definida por:
\begin{equation}
\begin{array}{ccc}
\widehat{f_1}&\widehat{f_2}&\widehat{f_3}\\
\widehat{f_4}&\circledtwochars{\widehat{f_5}}&\widehat{f_6}\\
\widehat{f_7}&\widehat{f_8}&\widehat{f_9}\\
\end{array}
\label{eq:vecindario3x3}\end{equation}
\noindent donde $\widehat{f_5}$ es el píxel central del entorno que se está considerando.\\
\noindent Utilizando \eqref{eq:mascarasSobelSTD}, en la pág. \pageref{eq:mascarasSobelSTD}, que muestra las máscaras originales del método de \emph{Sobel}, y siguiendo el método directo de \textsc{LIP}, se ha definido el \emph{\textsc{vector}} de \emph{tonos de gris} del método de \mbox{\emph{LIP--Sobel}}, $\vec{g}=(g_x,g_y)$, como:
\begin{eqnarray}
g_x = &\left(\widehat{f_1}\LIPplus \left(2\LIPtimes \widehat{f_4}\right) \LIPplus \widehat{f_7}\right)\LIPminus \left(\widehat{f_3}\LIPplus \left(2\LIPtimes \widehat{f_6}\right) \LIPplus \widehat{f_9}\right)\quad &\\
g_y = &\left(\widehat{f_1}\LIPplus \left(2\LIPtimes \widehat{f_2}\right) \LIPplus \widehat{f_3}\right)\LIPminus \left(\widehat{f_7}\LIPplus \left(2\LIPtimes \widehat{f_8}\right) \LIPplus \widehat{f_9}\right)\quad &
\end{eqnarray}
\noindent Los autores pudieron definir las fórmulas que generan el vector del método \mbox{\emph{LIP--Sobel}} porque se conocen los valores del filtro previamente y además, son constantes (valores positivos y negativos, que se tradujeron a la formulación directa de \textsc{LIP} mediante $\LIPplus$ ó $\LIPminus$, respectivamente). Utilizando la función isomórfica de transformación, $\varphi(\cdot)$, descrita en \eqref{eq:isomorTransf}, se obtiene (ver demostración en \citep[Apéndice 3]{deng98}):
\begin{eqnarray}
g_x = M-M\left(\frac{f_3 f_6^2 f_9}{f_1 f_4^2 f_7}\right)\label{eq:lipSobelGX}\\
g_y = M-M\left(\frac{f_1 f_2^2 f_3}{f_7 f_8^2 f_9}\right)\label{eq:lipSobelGY}
\end{eqnarray}
\noindent Se deduce fácilmente que \eqref{eq:lipSobelGX} y \eqref{eq:lipSobelGY} se pueden obtener directamente de la formulación de \mbox{\textsc{DGLIP--Conv}}, mostrada en \eqref{eq:prodLIPgt}, pág. \pageref{eq:prodLIPgt}, utilizando las máscaras definidas en \eqref{eq:mascarasSobelSTD}. Por tanto, \mbox{\textsc{DGLIP--Conv}} es una formulación más general que el método planteado por \person{Deng y Pinoli}, y consecuentemente, al ser equivalentes las dos formulaciones, \mbox{\textsc{FGLIP--Conv}}, también es una formulación más general que la propuesta por \person{Deng y Pinoli}.
\subsection{Resultados experimentales}
Aunque en el Cap. \ref{chap:criterios} se han seleccionado una serie de imágenes, para comprobar el correcto funcionamiento del método \emph{LIP--Sobel} en sus diferentes implementaciones y facilitar la comparación visual, se ha decidido utilizar alguna imagen conocida y habitual en las comparaciones del ámbito del \textsc{Procesamiento de Imágenes}. Para ello, se ha seleccionado la conocida imagen \texttt{peppers} (ver Fig. \ref{fig:originalPeppers}).%\clearpage
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/originalPeppers}\caption[Imagen Original]{Imagen \texttt{peppers} original.\label{fig:originalPeppers}}
\end{SCfigure}

\noindent La Fig. \ref{fig:darkenedPeppers} muestra la imagen resultante tras aplicar un proceso de oscurecimiento no lineal sobre la imagen original (Fig. \ref{fig:originalPeppers}). El proceso de oscurecimiento se ha realizado con la fórmula:
\begin{equation}
\mathrm{dark}(x,y) = \mathrm{img}(x,y)\cdot\left(0.1 + \frac{5\cdot\sin(2\pi x)}{6\cdot \mathrm{width}}\right).\label{eq:darkening}
\end{equation}
\noindent Donde ``$\mathrm{width}$'' es la anchura de la imagen que se desea oscurecer e $\mathrm{img}(x,y)$ es el valor del píxel $(x,y)$ de dicha imagen original.
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/darkenedPeppers}\caption[Imagen Oscurecida]{Imagen \texttt{peppers} oscurecida.}\label{fig:darkenedPeppers}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/peppersSobel}\caption[Imagen Sobel]{Sobel estándar aplicado sobre la imagen \texttt{peppers} oscurecida.\label{fig:stdsobel}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/peppersSobelLIPDengPinoli}\caption[Imagen LIP--Sobel]{LIP--Sobel aplicado sobre la imagen \texttt{peppers} oscurecida.\label{fig:lipsobel}}
\end{SCfigure}

\noindent A continuación, se muestran los resultados de \emph{LIP--Sobel} construidos con tres metodologías diferentes (siguiendo el método propuesto por \person{Deng y Pinoli} \citep{deng98}, mediante \mbox{\textsc{DGLIP--Conv}} y mediante \mbox{\textsc{FGLIP--Conv}}). Como era de esperar, los resultados obtenidos por los tres métodos son exactamente iguales, como demuestra que el \definicion[-2em]{\textsc{MSE}}{Del inglés, \textsc{Mean Squared Error}, Error cuadrático medio.} sea cero en todos los casos.
\subsubsection{LIP--Sobel implementado mediante el procedimiento de \person{Deng y Pinoli}}
En la Fig. \ref{fig:stdsobel} se muestra la imagen resultante de aplicar el método \emph{Sobel} estándar sobre la imagen oscurecida (Fig. \ref{fig:darkenedPeppers}). Se ha aplicado sobre la Fig. \ref{fig:darkenedPeppers} el método \emph{LIP--Sobel} tal y como fue propuesto por \person{Deng y Pinoli}, descrito en \eqref{eq:lipSobelGX} y \eqref{eq:lipSobelGY}. En la Fig. \ref{fig:lipsobel} se muestra la magnitud del gradiente de la imagen resultante. Como se puede observar en la imagen de la Fig. \ref{fig:stdsobel}, que muestra la aplicación del método \emph{Sobel} original, los bordes presentes en las regiones oscuras de la imagen original no se han detectado con claridad. Frente a esta imagen, se puede observar la Fig. \ref{fig:lipsobel}, donde se muestra el resultado del método \emph{LIP--Sobel}, en la que los bordes en las regiones oscuras se detectan de manera más homogénea. Este comportamiento es un beneficio colateral, debido a que \textsc{LIP} hace que la componente de \emph{iluminación} se pueda considerar constante en un entorno pequeño. Gracias al comportamiento logarítmico de \textsc{LIP}, dicha componente se elimina automáticamente al realizar la operación \emph{Convolución--\textsc{LIP}} con un filtro cuya suma de componentes sea nula, o bien, al realizar operaciones $\LIPplus$ y $\LIPminus$ que se compensen entre sí.
\subsubsection{LIP--Sobel implementado mediante \mbox{\textsc{FGLIP--Conv}} y \mbox{\textsc{DGLIP--Conv}}}

\noindent El filtro \emph{Sobel} estándar, mostrado en \eqref{eq:mascarasSobelSTD}, es un filtro separable, compuesto por dos vectores:
\begin{eqnarray}
\vec{a}&=&[-1,0,1]\nonumber\\
\vec{b}&=&[1,2,1]\label{eq:separableSobelMask}
\end{eqnarray}

\noindent Usando la propiedad de separabilidad de los filtros de \emph{Sobel}, se puede usar el operador \emph{Convolución--LIP}, implementado tanto por el método \mbox{\textsc{DGLIP--Conv}} como por el método \mbox{\textsc{FGLIP--Conv}}. De modo que para realizar el algoritmo \emph{LIP--Sobel} mediante el método \mbox{\textsc{DGLIP--Conv}}, se aplica \eqref{eq:prodLIPgt} utilizando $\vec{a}$ y $\vec{b}$ tal y como se ha propuesto en \eqref{eq:separableSobelMask} a la imagen oscurecida (Fig. \ref{fig:darkenedPeppers}). De manera análoga, se obtiene el mismo resultado utilizando el algoritmo \emph{LIP--Sobel} mediante el mecanismo \mbox{\textsc{FGLIP--Conv}}, para lo que se aplicará \eqref{eq:convLIPgt} con $\vec{a}$ y $\vec{b}$, descritos en \eqref{eq:separableSobelMask}. Los bordes detectados por \emph{LIP--Sobel} mediante cualquiera de los tres procedimientos (\person{Deng y Pinoli}, \mbox{\textsc{DGLIP--Conv}} y \mbox{\textsc{FGLIP--Conv}}) son los mismos y, como se ha comentado con anterioridad, el \textsc{MSE} es cero.
%\clearpage
\section{Filtros de emborronamiento}
\lettrine{E}{n} la aplicación previa se ha mostrado que los dos mecanismos propuestos para el desarrollo del operador \emph{Convolución--LIP} proporcionan los mismos resultados para un algoritmo en particular mediante el uso de un algoritmo diseñado específicamente. Sin embargo, el nuevo operador \emph{Convolución--LIP} es más interesante y versátil, y a continuación, se mostrarán experimentos que van a permitir refrendar esta afirmación.\\
\noindent Siguiendo el mismo procedimiento que utilizaron \person{Deng y Pinoli} para obtener la formulación con la que se implementó el método \emph{LIP--Sobel} original, se podría diseñar cualquier otro filtro. Sin embargo, cada filtro debería calcularse de manera explícita previamente; por ejemplo, aunque símplemente se desease modificar el tamaño del filtro para que tenga un entorno diferente, se debería calcular un filtro completamente nuevo, sin poder adaptarse el calculado previamente. Justo al contrario, el operador \emph{Convolución--LIP}, ya sea implementado mediante \mbox{\textsc{DGLIP--Conv}} o mediante \mbox{\textsc{FGLIP--Conv}}, permite utilizar el mismo código, simplemente cambiando los parámetros de entrada (los filtros 1D utilizados), lo cual se traduce en una ganancia en flexibilidad y, a su vez, en robustez de las aplicaciones. Además de estas ventajas, se obtiene una mejora en el tiempo de desarrollo y sobre todo en el tiempo de cómputo, como se mostrará en la Sec. \ref{sec:tiemposComputo}.
\subsection{Filtro Media: LIP--Avg}
En este apartado, se va a mostrar el que se puede considerar como ``mejor caso'' en términos de velocidad para el mecanismo de construcción de filtros siguiendo la filosofía \textsc{LIP} desarrollada por \person{Deng y Pinoli}. Para ello, sea un filtro en el que todos los elementos son constantes y con valores idénticos, por ejemplo, un filtro \emph{media}. Se afirma que éste es el ``mejor caso'' para el mecanismo de \person{Deng y Pinoli}, ya que la potenciación, que es una operación computacionalmente muy costosa, se puede realizar solo una única vez por filtro, tal y como se demuestra a continuación. Se compara este resultado con las imágenes resultantes obtenidas mediante \mbox{\textsc{DGLIP--Conv}} y mediante \mbox{\textsc{FGLIP--Conv}}, comprobándose que el resultado es el mismo, pero el tiempo de ejecución de estos últimos es menor que el ``mejor caso'' del mecanismo propuesto por \person{Deng y Pinoli}.
\subsubsection{LIP--Avg implementado mediante el procedimiento de \person{Deng y Pinoli}}
Se define un filtro de tamaño $n\times n$ píxeles para que calcule la media de dicho entorno siguiendo el paradigma \textsc{LIP}.  Como primer paso, se fija el valor de $n$, para poder construir la fórmula específica asociada al filtro \emph{media}. Por ejemplo, si se toma $n = 3$, se puede utilizar la misma definición de entorno de un píxel que en \eqref{eq:vecindario3x3}, con lo que se obtiene:
\begin{eqnarray}
\mathrm{avg^{3\times 3}_{LIP}}(f)=\Big( &\left(\frac{1}{9} \LIPtimes \widehat{f_1}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_2}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_3}\right)& \LIPplus \nonumber \\
&\left(\frac{1}{9} \LIPtimes \widehat{f_4}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_5}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_6}\right)& \LIPplus \nonumber \\
&\left(\frac{1}{9} \LIPtimes \widehat{f_7}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_8}\right)\LIPplus \left(\frac{1}{9} \LIPtimes \widehat{f_9}\right)\Big)&
\end{eqnarray}
\noindent Operando sobre esta fórmula, se obtiene:
\begin{equation}
\mathrm{avg^{3\times 3}_{LIP}}(f)= M - \left(f_1 \cdot f_2 \cdot f_3 \cdot f_4 \cdot f_5 \cdot f_6 \cdot f_7 \cdot f_8 \cdot f_9 \right)^{\frac{1}{9}}\\
\end{equation}
\noindent Que se podría abreviar como,
\begin{equation}
\mathrm{avg^{3\times 3}_{LIP}}(f)= M - \left(\prod^{9}_{i=1} f_i \right)^{\frac{1}{9}}
\end{equation}
\noindent Hay que notar que se puede tomar un exponente común $\left(\frac{1}{9}\right)$. Al utilizarlo, el tiempo de ejecución puede disminuir, ya que se reduce sensiblemente la complejidad de la fórmula que se ha de codificar.\\
\noindent También se ha probado con un entorno de mayor tamaño: $5 \times 5$. Para este caso, la nueva fórmula obtenida es:
\begin{equation}
\mathrm{avg^{5\times 5}_{LIP}}(f)= M - \left(\prod^{25}_{i=1} f_i \right)^{\frac{1}{25}}
\end{equation}
\noindent Está claro que para cada valor diferente de $n$, es decir, para cada tamaño del entorno que se considere, se tiene que calcular una nueva fórmula. Por lo tanto, es necesario reescribir nuevo código para cada nuevo tamaño del filtro.
\subsubsection{LIP--Avg implementado mediante \mbox{\textsc{DGLIP--Conv}} y \mbox{\textsc{FGLIP--Conv}}}
Mediante el operador \emph{Convolución--LIP} se puede construir fácilmente el filtro media siguiendo la metodología \textsc{LIP} para entornos de cualquier tamaño. Para implementar \emph{LIP--Avg} de $3\times 3$ píxeles, sólo se tiene que aplicar \eqref{eq:prodLIPgt} ó \eqref{eq:convLIPgt}, dependiendo de si la implementación es siguiendo el método \mbox{\textsc{DGLIP--Conv}} o \mbox{\textsc{FGLIP--Conv}} respectivamente, y utilizando como componentes del filtro los vectores $\vec{a} = \vec{b} =  \left[\frac{1}{3},\frac{1}{3},\frac{1}{3}\right]$.\\
\noindent Para calcular \emph{LIP--Avg} de $5\times 5$, se utiliza \eqref{eq:prodLIPgt} ó \eqref{eq:convLIPgt} con los vectores $\vec{a} = \vec{b} =  \left[\frac{1}{5},\frac{1}{5},\frac{1}{5},\frac{1}{5},\frac{1}{5} \right]$. Se puede deducir fácilmente que, simplemente, cambiando los filtros que se utilizan como parámetros de entrada, se puede obtener el cálculo de cualquier filtro \emph{media} para diferentes tamaños del entorno, sin necesidad de escribir una sola línea de código adicional.
\subsection{Filtro Gaussiano: LIP--GBlur}
En el apartado anterior, se han mostrado un par de ejemplos de lo que se puede considerar el caso más favorable para la metodología propuesta por \person{Deng y Pinoli}. Este ``mejor caso'' se debe a la reducción del número de exponenciaciones utilizadas, ya que cada píxel del entorno se eleva al mismo valor, y por tanto, se puede tomar un exponente común. Por tanto, el ``peor caso'' para la metodología de \person{Deng y Pinoli} es un filtro con valores  diferentes, en el que no se pudiera optimizar sacando un exponente común. Un ejemplo de este tipo es el de emborronamiento gaussiano, donde el filtro está generado por una gaussiana. Se ha escogido un filtro gaussiano bidimensional puesto que es separable: la manera habitual de calcular un filtro gaussiano bidimensional es mediante la multiplicación matricial de un filtro gaussiano unidimensinal (vector columna) por sí mismo traspuesto (vector fila). Para mostrar un ejemplo específico, se ha generado un filtro gaussiano de tamaño $7\times 7$ (ver Tab. \ref{tbl:gauss2d}), realizado mediante la aproximación de una gaussiana (con $\sigma = 1.0$) para una malla de $7\times 7$ píxeles.\\
\noindent A continuación, se muestran los resultados obtenidos por el filtro \emph{LIP--GBlur}, que muestra el emborronamiento gaussiano siguiendo la filosofía \textsc{LIP}, mediante los tres métodos indicados anteriormente. Como era de esperar, no se han obtenido diferencias entre los resultados obtenidos por los diferentes métodos para la implementación del mismo filtro.
\subsubsection{LIP--GBlur implementado mediante el procedimiento de \person{Deng y Pinoli}}
Se ha extendido la definición del entorno de píxeles en el mismo sentido de \eqref{eq:vecindario3x3} a un entorno de $7\times 7$ píxeles. El filtro gaussiano utilizado se detalla en la \mbox{Tab. \ref{tbl:gauss2d}}.
\begin{SCtable}[][!t]
  \begin{tabular}{|ccccccc|}
      \hline
      \small 0.0001 & \small 0.0015 & \small 0.0067 & \small 0.0111 & \small 0.0067 & \small 0.0015 & \small 0.0001\\
      \small 0.0015 & \small 0.0183 & \small 0.0821 & \small 0.1353 & \small 0.0821 & \small 0.0183 & \small 0.0015\\
      \small 0.0067 & \small 0.0821 & \small 0.3679 & \small 0.6065 & \small 0.3679 & \small 0.0821 & \small 0.0067\\
      \small 0.0111 & \small 0.1353 & \small 0.6065 & \small 1.0000 & \small 0.6065 & \small 0.1353 & \small 0.0111\\
      \small 0.0067 & \small 0.0821 & \small 0.3679 & \small 0.6065 & \small 0.3679 & \small 0.0821 & \small 0.0067\\
      \small 0.0015 & \small 0.0183 & \small 0.0821 & \small 0.1353 & \small 0.0821 & \small 0.0183 & \small 0.0015\\
      \small 0.0001 & \small 0.0015 & \small 0.0067 & \small 0.0111 & \small 0.0067 & \small 0.0015 & \small 0.0001\\
      \hline
  \end{tabular}\caption[Gauss $7\times 7$]{Malla de $7\times 7$ píxeles de un filtro gaussiano bidimensional (con $\sigma = 1.0$).\label{tbl:gauss2d}}
\end{SCtable}

\noindent La fórmula que se aplica para obtener el emborronamiento gaussiano bajo el paradigma \textsc{LIP}, \emph{LIP--GBlur}, se muestra en \eqref{eq:gaussianLIPdpOrig}, aunque por simplicidad, no se muestran todos los valores de la fórmula.
\begin{eqnarray}
&\mathrm{GBlur_{LIP}}(f)=&\nonumber \\
\Big( &\left(\scriptstyle{0.0001}\LIPtimes\widehat{f_1}\right)\LIPplus\left(\scriptstyle{0.0015}\LIPtimes \widehat{f_2}\right)\LIPplus\left(\scriptstyle{0.0067}\LIPtimes\widehat{f_3}\right)\LIPplus &\ldots \nonumber\\
\ldots &\left(\scriptstyle{0.1353}\LIPtimes\widehat{f_{23}}\right)\LIPplus\left(\scriptstyle{0.6065}\LIPtimes \widehat{f_{24}}\right)\LIPplus\left(\scriptstyle{1.0000}\LIPtimes\widehat{f_{25}}\right)\LIPplus &\ldots \nonumber \\
\ldots & \left(\scriptstyle{0.0067}\LIPtimes\widehat{f_{47}}\right)\LIPplus\left(\scriptstyle{0.0015}\LIPtimes \widehat{f_{48}}\right)\LIPplus\left(\scriptstyle{0.0001}\LIPtimes\widehat{f_{49}}\right)&\Big)\nonumber\\
\label{eq:gaussianLIPdpOrig}
\end{eqnarray}

\noindent Análogamente a lo realizado para obtener \eqref{eq:lipSobelGX} y \eqref{eq:lipSobelGY}, se obtiene la fórmula \eqref{eq:gaussianLIPdp}.
\begin{equation}
\mathrm{GBlur_{LIP}}(f)= M - \left(\frac{f_1^{\scriptscriptstyle{0.0001}} \cdot \ldots \cdot f_{24}^{\scriptscriptstyle{0.6065}} \cdot
 f_{25}^{\scriptscriptstyle{1.000}}\cdot\ldots\cdot f_{49}^{\scriptscriptstyle{0.0001}}}{M^{\scriptscriptstyle{0.0001
\cdot\ldots\cdot 0.6065 \cdot 1.0000 \cdot\ldots\cdot
0.0001}}}\right)\label{eq:gaussianLIPdp}
\end{equation}

\subsubsection{LIP--GBlur implementado mediante \mbox{\textsc{DGLIP--Conv}} y \mbox{\textsc{FGLIP--Conv}}}
Como se ha indicado anteriormente, la matriz bidimensional de una gaussiana es un filtro separable, construido a partir de la multiplicación de un vector de una gaussiana unidimensional consigo mismo. El tamaño del filtro depende del valor del parámetro $\sigma$: cuanto mayor es $\sigma$, más grande debe ser el tamaño del filtro para que pueda tener suficiente precisión. Como regla general, la longitud del filtro gaussiano, centrado sobre una posición específica, debe ser de $3.5\cdot\sigma^2$ valores a izquierda y derecha de dicha posición (está ampliamente aceptado el redondeo hacia el valor inferior). Por ejemplo, para $\sigma = 1$, se debe tomar un filtro gaussiano de tamaño $7$. Como ejemplo, para dicho valor de $\sigma$, en los experimentos se han utilizado los siguientes vectores:
\begin{equation}
      \vec{a} = \vec{b} = \left[0.011, 0.135, 0.606, 1, 0.606, 0.135, 0.011\right]
\end{equation}

\noindent Es evidente, que para un valor más grande de $\sigma$, se deberá utilizar un filtro de mayor tamaño. Sin embargo, no hay necesidad alguna de reescribir ninguna línea de código, simplemente basta con cambiar los parámetros de entrada para obtener la salida deseada. Esto es una de las mayores contribuciones de esta nueva reformulación del operador \emph{convolución} utilizando el paradigma \textsc{LIP}, propuesto en este trabajo.

\section{Filtros para la extracción de bordes}
\lettrine{C}{omo} se ha expuesto en capítulos anteriores, los algoritmos de extracción de bordes serán las aplicaciones principales que se van a desarrollar en esta Tesis Doctoral. Por ese motivo, en este capítulo se mostrará el funcionamiento de los algoritmos de extracción de bordes seleccionados en el Cap. \ref{chap:criterios}. El primero de los algoritmos de extracción de bordes seleccionados, \emph{LIP--Sobel} ya se ha expuesto en la Sec. \ref{sec:lipSobel}. A continuación, se describirán y mostrarán los dos restantes, \emph{LIP--LoG} y \emph{LIP--Canny}, que son la implementación bajo el modelo \textsc{LIP} de los algoritmos \emph{LoG} y \emph{Canny}, descritos en el Cap. \ref{chap:ProcImagenes}.
\subsection{Laplaciano de Gaussianas: LIP--LoG}
Existen muchos métodos para la extracción de bordes de una imagen digital. Como se observó anteriormente, \emph{Sobel} es un algoritmo para la obtención de los contornos. Este método se basa en filtros fijos de un tamaño pequeño. Sin embargo, existen otros métodos que tienen filtros de tamaño variable y con valores en función del tamaño. Uno de estos métodos es el llamado \emph{Laplaciano de Gaussianas}, también conocido como \emph{LoG}. Este operador es la suma de la segunda derivada parcial en cada dirección sobre la imagen que previamente ha sufrido un emborronamiento gaussiano, aunque estas dos operaciones se hacen simultáneamente, resultando en una mayor efectividad. El operador bidimensional \emph{LoG} se realiza mediante la \emph{convolución} de una imagen con un filtro \emph{LoG} bidimensional, tal y como se muestra en \eqref{eq:LoG_2D}.
\begin{equation}
LoG(I,\sigma)=\nabla^2\left\{\convtwod{\Big(I,G_\sigma(x,y)\Big)}\right\} = \convtwod\bigg(I, \Big(\nabla^2 G_\sigma(x,y)\Big)\bigg) \label{eq:LoG_2D}
\end{equation}
\noindent donde $G_\sigma(x,y)$ simboliza la función 2D gaussiana descrita en \eqref{eq:Gaussian_2D} y $\nabla^2 G(x,y)$ es la suma de las segundas derivadas parciales direccionales de $G(x,y)$ mostradas en \eqref{eq:laplaciano2}.
\begin{equation}
H(x,y) = \nabla^2 G(x,y) = \frac{\partial^2 G(x,y)}{\partial x^2} + \frac{\partial^2 G(x,y)}{\partial y^2} = \frac{x^2 +y^2-2\sigma^2}{\sigma^4}e^{-\frac{x^2+y^2}{2\sigma^2}} \label{eq:laplaciano2}
\end{equation}
\noindent El detector de bordes \emph{Laplaciano de Gaussianas} habitualmente se implementa utilizando un filtro bidimensional, como se ha indicado anteriormente; sin embargo, se ha demostrado que el filtro \emph{LoG} es separable (ver \citep{vernon91} para la demostración de separabilidad del filtro \emph{LoG}) y dicha aproximación es la utilizada en este trabajo, tanto para implementar el filtro original \emph{LoG} como para la versión \emph{LIP--LoG} mediante \mbox{\textsc{FGLIP--Conv}}. Sin embargo, para implementar \emph{LIP--LoG} utilizando la metodología propuesta por \person{Deng y Pinoli} no se pueden utilizar filtros separables ya que no ha sido desarrollado así originalmente; al contrario se ha utilizado un filtro bidimensional \emph{LoG} descrito en \eqref{eq:laplaciano2}. La formulación separable del filtro \emph{LoG} se muestra en \eqref{eq:LoG_separable}:
\begin{equation}\label{eq:LoG_separable}
\begin{split}
LoG(I,\sigma)=\nabla^2\Big\{&\convtwod{\Big(I,G_\sigma\Big)}\Big\} = \convoned\bigg(\convoned\Big(I,\vec{a_\sigma}(x)\Big),\vec{g_\sigma}(y)\bigg) + \\
&\convoned\bigg(\convoned\Big(I,\vec{a_\sigma}(y)\Big),\vec{g_\sigma}(x)\bigg)
\end{split}
\end{equation}
\noindent donde $G_\sigma(x,y)$ es una función gaussiana bidimensional, $\vec{g_\sigma}(t)$ representa una función gaussiana unidimensional y $\vec{a_\sigma}(t)$ muestra la segunda derivada de la función gaussiana unidimensional, definidas respectivamente como:
\begin{eqnarray}
G_\sigma(x,y) & = & \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}} \\ \label{eq:Gaussian_2D}
\vec{g_\sigma}(t) & = &\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{t^2}{2\sigma^2}} \\ \label{eq:Gaussian_1D}
\vec{a_\sigma}(t) & = & \frac{\partial^2 G_\sigma(t)}{\partial t^2} \label{eq:laplacianGaussian_1D}
\end{eqnarray}
\noindent El tamaño del filtro de \emph{Sobel} es de $3\times 3$, sin embargo, para poder utilizar un filtro \emph{LoG} se necesita un filtro con un tamaño mayor, para este caso en particular se utiliza un filtro \emph{LoG} de $7\times 7$ píxeles. Es decir, que se tienen $49$ elementos, cada uno con un valor diferente calculado a partir de la fórmula \emph{LoG} descrita en \eqref{eq:Gaussian_2D}. Esto está en relación directa con el tamaño del filtro gaussiano y, obviamente, con las derivadas parciales de segundo orden del mismo.\\
\noindent Aunque \person{Deng y Pinoli} no establecieron explícitamente un filtro \mbox{\emph{LIP--LoG}}, es fácil extender el mecanismo que los autores utilizaron al definir la versión original del \emph{LIP--Sobel} para obtener un mecanismo análogo y obtener un filtro \emph{LIP--LoG}, cuya fórmula viene dada por:
\begin{equation}
LoG_{\upDelta}^{7\times 7}(\widehat{f}) = \LIPsum{i=1}{7}\ \ \LIPsum{j=1}{7} \left(H(i,j)\LIPtimes\widehat{f}(i,j)\right)
\end{equation}
\noindent que se traduce a la siguiente fórmula:
\begin{equation}
LoG_{\upDelta}^{7\times 7}(\widehat{f}) = \prod_{i=1}^{7}\prod_{j=1}^{7}\left(f(i,j)^{H(i,j)}\right),\label{eq:LoG_DP}
\end{equation}
\noindent donde $H(i,j)$ es el filtro \emph{LoG} bidimensional definido en \eqref{eq:laplaciano2} y $f(i,j)$ son cada uno de los $49$ \emph{tonos de gris} diferentes de la imagen de cada \emph{convolución}.\\
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/originalLenna}\caption[\texttt{Lenna} Original]{Imagen \texttt{Lenna} original.\label{fig:lennaOriginal}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/darkenedLenna}\caption[\texttt{Lenna} Oscurecida]{Imagen \texttt{Lenna} oscurecida.\label{fig:lennaOscurecida}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/darkenedLennaLoG}\caption[LoG \texttt{Lenna} Oscurecida]{LoG sobre la imagen \texttt{Lenna} oscurecida.\label{fig:LoGlennaOscurecida}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/thresh10b_darkenedLennaLoG}\caption[LoG umbralizado \texttt{Lenna} Oscurecida]{LoG umbralizado (con $umbral = 10$) sobre la imagen \texttt{Lenna} oscurecida.\label{fig:threshLoGlennaOscurecida}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/darkenedLennaLoG_LIP}\caption[LOG--LIP \texttt{Lenna} Oscurecida]{LoG--LIP sobre la imagen \texttt{Lenna} oscurecida.\label{fig:LogLIPlennaOscurecida}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/thresh10b_darkenedLennaLoG_LIP}\caption[LOG--LIP umbralizado Lenna Oscurecida]{LoG--LIP umbralizado (con $umbral = 10$) sobre la imagen \texttt{Lenna} oscurecida.\label{fig:threshLogLIPlennaOscurecida}}
\end{SCfigure}

\noindent Por el mismo motivo que en el caso del método \emph{LIP--Sobel}, se ha comprobado el funcionamiento de estos operadores que se han descrito, utilizando una imagen conocida y de uso común, \texttt{Lenna} (Fig. \ref{fig:lennaOriginal}). Esta imagen ha sido modificada mediante la aplicación una banda de oscurecimiento sobre los ojos (Fig. \ref{fig:lennaOscurecida}). Se ha calculado el filtro \emph{LoG} (con $\sigma = 1.0$) aplicando \eqref{eq:LoG_2D} sobre la imagen oscurecida, obteniéndose la Fig. \ref{fig:LoGlennaOscurecida}, que ha sido umbralizada con un $umbral = 10$ y se ha generado la Fig. \ref{fig:threshLoGlennaOscurecida}. Por otra parte, se ha aplicado el operador \emph{LIP--LoG} (con $\sigma=1.0$), obteniéndose Fig. \ref{fig:LogLIPlennaOscurecida}, que ha sido umbralizada también con un valor de $umbral = 10$ generando la Fig. \ref{fig:threshLogLIPlennaOscurecida}. Como se puede observar por simple inspección, la imagen umbralizada tras el operador \emph{LIP--LoG} proporciona bordes en la zona oscurecida, frente a la imagen umbralizada tras aplicar el operador \emph{LoG}, el cual no obtiene bordes en dicha zona.
%\clearpage
\subsection{LIP--Canny}\label{sec:lipCanny}
El método de \emph{Canny} \citep{canny86} es un método muy robusto para la extracción de bordes en imágenes naturales que pueden tener presencia de ruido blanco gaussiano. En este apartado se propone un experimento que consiste en la aplicación del paradigma \textsc{LIP} al extractor de bordes de \emph{Canny}. La adaptación a \textsc{LIP} se realiza en los primeros pasos, la obtención de los mapas de gradiente, en lugar de utilizar el operador \emph{convolución} estándar se utiliza el operador \emph{Convolución--\textsc{LIP}} expuesto en \eqref{eq:convLIPgt}. En el experimento realizado, se ha obtenido el mapa de bordes mediante tres mecanismos:
\begin{itemize}
\item Utilizando únicamente el método de \emph{Canny} tradicional.
\item Mediante una técnica híbrida en la que primero se aplica \emph{Filtrado Homomórfico} y posteriormente el método de \emph{Canny} tradicional.
\item A través de un nuevo método propuesto, \emph{LIP--Canny}.
\end{itemize}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/soportales.jpg}\caption[Sombras Original]{Imagen de un soportal con sombras naturales.\label{fig:soportales}}
\end{SCfigure}

\noindent Debido a la necesidad de comprobar el correcto funcionamiento en imágenes con sombras proyectadas reales, para este experimento se va a utilizar una de las imágenes seleccionadas en el Cap. \ref{chap:criterios}. Se ha escogido la \texttt{Imagen 4} del \textsc{dominio} \texttt{exteriores}, que se muestra en la Fig. \ref{fig:soportales}. Como puede observarse, esta imagen representa una fotografía de un soportal, parte del cual está en sombras. Utilizando esta imagen, se ha obtenido la Fig. \ref{fig:soportalesCanny} que muestra los bordes mediante el método tradicional de \emph{Canny}. La Fig. \ref{fig:soportalesFHCanny} contiene los contornos obtenidos mediante la aplicación del \emph{Filtrado Homomórfico} seguido del método de \emph{Canny} habitual y por último, los bordes utilizando el nuevo método propuesto \emph{LIP--Canny} se muestran en la Fig. \ref{fig:soportalesLIPCanny}. Para todos los métodos se han utilizado los valores de los parámetros que han proporcionado en cada caso los mejores resultados, calculados estos mediante métodos subjetivos. De manera común a todos los métodos, se ha tomado \mbox{$\sigma$ = 1.0}, donde $\sigma$ es el valor de la amplitud de la campana de la gaussiana utilizada en las primeras fases de \emph{convolución}.

\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/soportales_canny.jpg}\caption[Canny]{Mapa de bordes obtenidos utilizando \emph{Canny}. Parámetros: $\mathrm{th}_\mathrm{low} =$ 0.05, $\mathrm{th}_\mathrm{high} =$ 0.125.\label{fig:soportalesCanny}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/soportales_FH+Canny.jpg}\caption[\emph{Filtrado Homomórfico}+Canny]{Mapa de bordes obtenidos utilizando \emph{Filtrado Homomórfico} seguido de \emph{Canny}. Parámetros: $\mathrm{th}_\mathrm{low}=$ 0.01, \mbox{$\mathrm{th}_\mathrm{high} =$ 0.05.}\label{fig:soportalesFHCanny}}
\end{SCfigure}
\begin{SCfigure}[][!t]
\includegraphics[width=21pc]{gfx/soportales_LIP-Canny.jpg}\caption[LIP--Canny]{Mapa de bordes obtenidos utilizando \emph{LIP--Canny}. Parámetros: $\mathrm{th}_\mathrm{low}=$ 0.05, \mbox{$\mathrm{th}_\mathrm{high} =$ 0.4.}\label{fig:soportalesLIPCanny}}
\end{SCfigure}
\FloatBarrier
\noindent Como se puede observar, el método \emph{LIP--Canny} obtiene una mayor cantidad de bordes que el método de \emph{Canny} para el mismo valor de umbral. Es más, el método \emph{LIP--Canny} obtiene bordes precisos en la zona donde se proyecta la sombra, en la cual, el método tradicional de \emph{Canny} no detecta ningún borde. Para que el algoritmo tradicional de \emph{Canny} sea capaz de detectar dichos bordes, es necesario aplicar un paso previo de \emph{Filtrado Homomórfico}. En este caso, el ajuste del umbral tiene que ser mucho más preciso, puesto que los valores del gradiente con los que opera \emph{Canny} tras el \emph{Filtrado Homomórfico} son mucho más pequeños.\\
\noindent En la imagen de contornos obtenidos mediante \emph{LIP--Canny}, Fig. \ref{fig:soportalesLIPCanny}, se muestran los bordes de las cristaleras de la pared trasera de los soportales, que se encuentran en una zona de sombras en la imagen original, Fig. \ref{fig:soportales}. Por el contrario, en la Fig. \ref{fig:soportalesCanny}, que contiene el mapa de bordes obtenidos por \emph{Canny}, no aparecen esos mismos elementos.\\
\noindent Hay que indicar que los parámetros de los umbrales en el método de \emph{LIP--Canny} son más altos que los mismos para el método de \emph{Canny}, ya que para el mismo nivel de los umbrales, \emph{LIP--Canny} es capaz de detectar muchos más contornos que \emph{Canny}. Por otro lado, al aplicar el algoritmo compuesto por el \emph{Filtrado Homomórfico} seguido del método de \emph{Canny} aparece un gran problema de sensibilidad del umbral superior. Es decir, se dejan de detectar la gran mayoría de bordes si se selecciona un umbral algo mayor que el óptimo, y al contrario, se comienzan a detectar una cantidad excesiva de contornos en cuanto se desciende por debajo de dicho umbral. Lo que, en definitiva, hace que \emph{LIP--Canny} se pueda considerar como el mecanismo más robusto y versátil de los 3 comparados en este experimento.
\section{Tiempos de cómputo}\label{sec:tiemposComputo}
\lettrine{E}{n} las secciones anteriores, se ha mostrado que los algoritmos implementados mediante el operador propuesto \emph{Convolución--\textsc{LIP}} presentan una respuesta visual mejor en todos los casos que los algoritmos equivalentes \textsc{No LIP}. En esta sección, se muestran los tiempos de cómputo obtenidos para los diversos experimentos descritos con anterioridad y la comparación de los diferentes métodos en consideración. En general, los tiempos de cálculo que se muestran en este trabajo se han obtenido implementando todos los algoritmos y métodos utilizando MATLAB\copyright 7 (R14) utilizando la Image Processing Toolbox y ejecutando los mismos en igualdad de carga computacional sobre un sistema Pentium\copyright Centrino M725 a 1.60 GHz (2MB L2--Cache) con 512 MB RAM.\\
\noindent Esta sección describe los resultados obtenidos en cada uno de los experimentos sin entrar en valoraciones o análisis de mayor profundidad, que se realizan en la Sec. \ref{sec:resumenResultados}.
\subsection{Aumento del rendimiento (\emph{Speedup})}
\noindent Además de mostrar el tiempo de cálculo de cada experimento, también se va a incluir otra medida, la ganancia de velocidad o \emph{Speedup}, que se nota como $S$, y se calcula mediante la siguiente fórmula matemática:
\begin{equation}
S = \frac{\mathrm{T_{referencia}}}{\mathrm{T_{nuevo}}}\label{eq:speedup}
\end{equation}
\noindent Este término describe la velocidad relativa de un sistema nuevo ($\mathrm{T_{nuevo}}$) en relación a otro sistema, que es tomado como referencia ($\mathrm{T_{referencia}}$). Si el valor de ganancia de velocidad es superior a uno, significa que el nuevo sistema es más rápido que el de referencia; y al contrario, si el \emph{Speedup} es inferior a uno, el nuevo sistema se comporta de una manera más lenta que el de referencia.
\subsection{LIP--Sobel}
Se han realizado una serie de experimentos con \emph{LIP--Sobel}, que se han descrito anteriormente. En la Tab. \ref{tbl:timeLIPSobel} se muestra el tiempo de cálculo para el algoritmo \emph{LIP--Sobel}, implementado en las tres versiones en consideración (\person{Deng y Pinoli}, \mbox{\textsc{DGLIP--Conv}} y \mbox{\textsc{FGLIP--Conv}}) y con imágenes de dos tamaños diferentes ($512 \times 512$ y $320 \times 240$).\\
\noindent Aunque en la Sec. \ref{sec:lipsobelResultados} se realiza un análisis más profundo de estos datos, es conveniente indicar que para este experimento en particular, la versión más rápida es la implementada utilizando \mbox{\textsc{FGLIP--Conv}}. Por el contrario, la versión de \emph{LIP--Sobel} mediante \mbox{\textsc{DGLIP--Conv}} es más lenta que la implementación propuesta por \person{Deng y Pinoli}. Esta situación ocurre debido a que, como se ha indicado en la Sec. \ref{sec:lipSobel}, la formulación obtenida por \person{Deng y Pinoli} es una instanciación concreta, optimizada para que dicha formulación sea compacta. A su vez, dicha formulación es equivalente a la obtenida por el mécanismo \mbox{\textsc{DGLIP--Conv}}, que sin embargo, es de carácter general y no se encuentra optimizada para la minimización del número de operaciones.
\begin{SCtable}[][!h]
\begin{tabular}{p{.3\textwidth}lll} \hline
\rowcolor{colorCorporativoSuave} \textsc{Algoritmo} & \textsc{Tamaño} & \textsc{Método} & \textsc{Tiempo} \\
\hline \hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli}      & \cellcolor{colorCorporativoMasSuave} 1.008 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoSuave} \mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoSuave} 0.450 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \multirow{-3}{*}{\cellcolor{colorCorporativoMasSuave}$512 \times 512$} & \cellcolor{colorCorporativoMasSuave} \mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave} 5.847 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoSuave} {Deng y Pinoli}      & \cellcolor{colorCorporativoSuave} 0.386 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoMasSuave} \mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave} 0.155 \\
\cline{3-4}
\multirow{-6}{*}{\cellcolor{colorCorporativoMedio} LIP--Sobel}  & \multirow{-3}{*}{\cellcolor{colorCorporativoSuave}$320 \times 240$} & \cellcolor{colorCorporativoSuave} \mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoSuave} 1.682 \\
\multicolumn{4}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Tiempos cálculo]{Comparación de tiempos de cálculo (tiempo en segundos).\label{tbl:timeLIPSobel}}
\end{SCtable}

\subsubsection{Aumento del rendimiento (\emph{Speedup})}
\noindent En la Tab. \ref{tbl:speedupLIPSobel} se muestra el aumento del rendimiento de \emph{LIP--Sobel} implementado con \mbox{\textsc{FGLIP--Conv}} y \mbox{\textsc{DGLIP--Conv}}, en relación con el método original propuesto por \person{Deng y Pinoli}.
\begin{SCtable}[][!ht]
\begin{tabular}{p{0.2\textwidth}ccc} \hline
\rowcolor{colorCorporativoSuave} & & \multicolumn{2}{c}{\cellcolor{colorCorporativoSuave}\textsc{Speedup respecto Deng y Pinoli}}\\
\cline{3-4}
\rowcolor{colorCorporativoSuave} \textsc{Algoritmo}  & \textsc{Tamaño} & \mbox{\textsc{FGLIP--Conv}} & \mbox{\textsc{DGLIP--Conv}} \\
\hline \hline
\cellcolor{colorCorporativoMedio}            & \cellcolor{colorCorporativoMasSuave} $512\times 512$   & \cellcolor{colorCorporativoMasSuave} 2.24   & \cellcolor{colorCorporativoMasSuave} 0.17 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio} \multirow{-2}{*}{LIP--Sobel} & \cellcolor{colorCorporativoSuave} $320\times 240$   & \cellcolor{colorCorporativoSuave} 2.49   & \cellcolor{colorCorporativoSuave} 0.23 \\
\multicolumn{4}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Speedup LIP--Sobel]{Speedup del \emph{LIP--Sobel} con respecto al mismo implementado mediante la técnica de \person{Deng y Pinoli}.\label{tbl:speedupLIPSobel}}
\end{SCtable}
\subsection{Algoritmos de emborronamiento: LIP--Avg, LIP--GBlur}
Los algoritmos de emborronamiento se han agrupado y se muestran tanto los tiempos de cálculo como el \emph{Speedup} (este último siempre tomando como referencia el tiempo obtenido por el algoritmo implementado mediante la técnica de \person{Deng y Pinoli}). Se han realizado tres experimentos diferentes:
\begin{itemize}
\item Emborronamiento por filtro media de tamaño $3 \times 3$ píxeles.
\item Emborronamiento por filtro media de tamaño $5 \times 5$ píxeles.
\item Emborronamiento por filtro gaussiano de tamaño $7 \times 7$ píxeles.
\end{itemize}
\noindent Estos experimentos se han realizado para dos tamaños de imágenes diferentes ($512 \times 512$ y $320 \times 240$ píxeles). Y se han realizado mediante las tres técnicas \textsc{LIP} en consideración:
\begin{itemize}
\item El método propuesto por \person{Deng y Pinoli}.
\item Mediante \emph{Convolución--LIP} implementado utilizando:
\begin{itemize}
\item \mbox{\textsc{DGLIP--Conv}}.
\item \mbox{\textsc{FGLIP--Conv}}.
\end{itemize}
\end{itemize}
\subsubsection{Tiempos de Cálculo}
En la Tab. \ref{tbl:timeBlur} se muestran los tiempos de los distintos experimentos sobre la misma arquitectura que la descrita para el experimento \emph{LIP--Sobel}. En esta tabla se vuelve a mostrar, que para todos los algoritmos de este experimento, las versiones más rápidas son aquellas implementadas mediante \mbox{\textsc{FGLIP--Conv}}. Por el contrario, tanto para los algoritmos \emph{LIP--Avg (3$\times$ 3)} como para \emph{LIP--Avg (5$\times$ 5)}, al igual que ocurría en el experimento \emph{LIP--Sobel}, las implementaciones de los algoritmos que utilizan \mbox{\textsc{DGLIP--Conv}} son las más lentas. Sin embargo, para el algoritmo \emph{LIP--GBlur}, la implementación mediante el mecanismo propuesto por \person{Deng y Pinoli} es claramente la más lenta, ya que no puede aprovecharse de la optimización y compactación de la fórmula matemática que trae dicha propuesta y, por el contrario, tanto \mbox{\textsc{FGLIP--Conv}} como \mbox{\textsc{DGLIP--Conv}} pueden hacer uso de la ventaja computacional que les ofrece la separabilidad de los filtros.
\begin{SCtable}[][!t]
\begin{tabular}{p{0.3\textwidth}lll} \hline
\rowcolor{colorCorporativoSuave}\textsc{Algoritmo} & \textsc{Tamaño} & \textsc{Método} & \textsc{Tiempo} \\
\hline \hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoMasSuave}0.456 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoSuave}0.192 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}\multirow{-3}{*}{$512 \times 512$} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}3.448 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoSuave}0.227 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}0.076 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio}\multirow{-6}{*}{LIP--Avg ($3 \times 3$)} &\cellcolor{colorCorporativoSuave}\multirow{-3}{*}{$320 \times 240$} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoSuave}1.017 \\
\hline
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoMasSuave}0.482 \\
\cline{3-4}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoSuave}0.198 \\
\cline{3-4}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoMasSuave}\multirow{-3}{*}{$512 \times 512$} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}4.056 \\
\cline{2-4}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoSuave}0.246 \\
\cline{3-4}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}0.077 \\
\cline{3-4}
\cellcolor{colorCorporativoMedioSuave}\multirow{-6}{*}{LIP--Avg ($5 \times 5$)} & \cellcolor{colorCorporativoSuave}\multirow{-3}{*}{$320 \times 240$}& \cellcolor{colorCorporativoSuave}\mbox{\textsc{DGLIP--Conv}} & \cellcolor{colorCorporativoSuave}1.189 \\
\hline
\cellcolor{colorCorporativoMedio} &\cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoMasSuave}9.629 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{FGLIP--Conv}} & \cellcolor{colorCorporativoSuave}0.333 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave} \multirow{-3}{*}{$512 \times 512$} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{DGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}4.560 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoSuave}2.855 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoSuave} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{FGLIP--Conv}}  & \cellcolor{colorCorporativoMasSuave}0.175 \\
\cline{3-4}
\cellcolor{colorCorporativoMedio}\multirow{-6}{*}{LIP--GBlur} & \cellcolor{colorCorporativoSuave} \multirow{-3}{*}{$320 \times 240$}& \cellcolor{colorCorporativoSuave}\mbox{\textsc{DGLIP--Conv}} & \cellcolor{colorCorporativoSuave}1.421 \\
\multicolumn{4}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Tiempos cálculo]{Comparación de tiempos de cálculo (tiempo en segundos).\label{tbl:timeBlur}}
\end{SCtable}
\subsubsection{Aumento del rendimiento (\emph{Speedup})}
De manera similar a lo expuesto en el experimento anterior, en la Tab. \ref{tbl:speedupBlur} se indica el \emph{Speedup}, tomando como referencia el tiempo de cada experimento implementado utilizando el método propuesto por \person{Deng y Pinoli}.
\begin{SCtable}[][!ht]
\begin{tabular}{p{0.3\textwidth}ccc} \hline
\rowcolor{colorCorporativoSuave} & & \multicolumn{2}{c}{\cellcolor{colorCorporativoSuave}\textsc{Speedup respecto Deng y Pinoli}}\\
\cline{3-4}
\rowcolor{colorCorporativoSuave}\textsc{Algoritmo}  & \textsc{Tamaño} & \mbox{\textsc{FGLIP--Conv}} & \mbox{\textsc{DGLIP--Conv}} \\
\hline\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}$512\times 512$   & \cellcolor{colorCorporativoMasSuave}2.38   & \cellcolor{colorCorporativoMasSuave}0.13 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio}\multirow{-2}{*}{LIP--Avg ($3\times 3$)} & \cellcolor{colorCorporativoSuave} $320\times 240$   & \cellcolor{colorCorporativoSuave}2.99   & \cellcolor{colorCorporativoSuave}0.22 \\
\hline
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoMasSuave}$512\times 512$   & \cellcolor{colorCorporativoMasSuave}2.43   & \cellcolor{colorCorporativoMasSuave}0.12 \\
\cline{2-4}
\cellcolor{colorCorporativoMedioSuave}\multirow{-2}{*}{LIP--Avg ($5\times 5$)} & \cellcolor{colorCorporativoSuave}$320\times 240$   & \cellcolor{colorCorporativoSuave}3.20   & \cellcolor{colorCorporativoSuave}0.21 \\
\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}$512\times 512$   & \cellcolor{colorCorporativoMasSuave}28.92  & \cellcolor{colorCorporativoMasSuave}2.11 \\
\cline{2-4}
\cellcolor{colorCorporativoMedio}\multirow{-2}{*}{LIP--GBlur} & \cellcolor{colorCorporativoSuave}$320\times 240$   & \cellcolor{colorCorporativoSuave}16.31  & \cellcolor{colorCorporativoSuave}2.01 \\
\multicolumn{4}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Speedup LIP--Avg, LIP--GBlur]{Speedup para cada experimento y método con respecto al mismo implementado mediante la técnica de \person{Deng y Pinoli}.\label{tbl:speedupBlur}}
\end{SCtable}
\subsection{Extracción de bordes: LIP--LoG}
En este apartado se muestran los resultados obtenidos al implementar el algoritmo \emph{LIP--LoG}. Para este algoritmo se han realizado otros experimentos diferentes a los casos anteriores; se compara el algoritmo original \textsc{No LIP}, es decir, el algoritmo original \emph{LoG}, con los algoritmos \textsc{LIP} tanto por el método de \person{Deng y Pinoli}, como por \emph{Convolución--LIP} utilizando la aproximación \mbox{\textsc{FGLIP--Conv}}, que se ha demostrado ser la aproximación más rápida. Las imágenes utilizadas tienen tamaños de $512 \times 512$ y de $256 \times 256$ píxeles.
\subsubsection{Tiempo de Cálculo}
En la Tab. \ref{tbl:timeLoG} se muestran los tiempos de cálculo para los diferentes experimentos. Se observa que \mbox{\textsc{FGLIP--Conv}} es la implementación más rápida, mientras que la implementación mediante el mecanismo propuesto por \person{Deng y Pinoli} es la más lenta.
\begin{SCtable}[!ht]
\begin{tabular}{p{0.4\textwidth}lc} \hline
\rowcolor{colorCorporativoSuave}\textsc{Tamaño}    & \textsc{Método} & \textsc{Tiempo}\\
\hline\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}Standard LoG & \cellcolor{colorCorporativoMasSuave}0.1357\\
\cline{2-3}
\cellcolor{colorCorporativoMedio}$512 \times 512$ & \cellcolor{colorCorporativoSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoSuave}7.8312\\
\cline{2-3}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{FGLIP--Conv}} & \cellcolor{colorCorporativoMasSuave}0.2163\\
\hline
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}Standard LoG & \cellcolor{colorCorporativoSuave}0.0390\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave}$256 \times 256$ & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli} & \cellcolor{colorCorporativoMasSuave}1.2042\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{FGLIP--Conv}} & \cellcolor{colorCorporativoSuave}0.0636\\
\multicolumn{3}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Tiempos LoG y LIP--LoG]{Comparación de tiempos de cálculo (tiempo en segundos) del experimento \emph{LoG} y \emph{LIP--LoG}.\label{tbl:timeLoG}}
\end{SCtable}
\subsubsection{Aumento del rendimiento (\emph{Speedup})}
Para este experimento se indican dos medidas de \emph{Speedup}. El primero, \textsc{Speedup d\&p.}, tomando como referencia el método de \person{Deng y Pinoli}; mientras que el segundo (denominado \textsc{Speedup fg.}), toma como referencia el método \mbox{\textsc{FGLIP--Conv}}. Los valores se muestran en la Tab. \ref{tbl:speedupLoG}.
\begin{SCtable}[][!ht]
\begin{tabular}{p{0.15\textwidth}lcc} \hline
\rowcolor{colorCorporativoSuave}\textsc{Tamaño}    & \textsc{Método} & \textsc{Speedup d\&p.} & \textsc{Speedup fg.}\\
\hline\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}Standard LoG               & \cellcolor{colorCorporativoMasSuave}57.71 & \cellcolor{colorCorporativoMasSuave}1.59\\
\cline{2-4}
\cellcolor{colorCorporativoMedio}$512 \times 512$ & \cellcolor{colorCorporativoSuave} {Deng y Pinoli}     & \cellcolor{colorCorporativoSuave}1.00  & \cellcolor{colorCorporativoSuave}0.03\\
\cline{2-4}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}\mbox{\textsc{FGLIP--Conv}}       & \cellcolor{colorCorporativoMasSuave}36.20 & \cellcolor{colorCorporativoMasSuave}1.00\\
\hline
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}Standard LoG               & \cellcolor{colorCorporativoSuave}30.88 & \cellcolor{colorCorporativoSuave}1.63\\
\cline{2-4}
\cellcolor{colorCorporativoMedioSuave}$256 \times 256$ & \cellcolor{colorCorporativoMasSuave} {Deng y Pinoli}     & \cellcolor{colorCorporativoMasSuave}1.00  & \cellcolor{colorCorporativoMasSuave}0.05\\
\cline{2-4}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}\mbox{\textsc{FGLIP--Conv}}       & \cellcolor{colorCorporativoSuave}18.93 & \cellcolor{colorCorporativoSuave}1.00\\
\multicolumn{4}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Speedup LoG y LIP--LoG]{Comparación de \emph{Speedup} del experimento \emph{LoG} y  \emph{LIP--LoG}.\label{tbl:speedupLoG}}
\end{SCtable}
\subsection{Extracción de bordes: LIP--Canny}
Este experimento, en el que se utiliza el algoritmo de extracción de bordes de \emph{Canny}, compara dos aproximaciones invariantes ante cambios de iluminación y la versión original del algoritmo. Las dos aproximaciones invariantes ante cambios de iluminación son:
\begin{itemize}
\item El algoritmo \emph{LIP--Canny} utilizando \mbox{\textsc{FGLIP--Conv}}, tal y como se ha indicado en Sec. \ref{sec:lipCanny}.
\item Un preprocesamiento previo de la imagen mediante \emph{Filtrado Homomórfico} y posterior aplicación del algoritmo estándar de \emph{Canny} sobre la imagen reflectancia obtenida del paso de preprocesamiento anterior.
\end{itemize}
\noindent Las imágenes son diferentes de las utilizadas con anterioridad, ya que debían incluir sombras proyectadas naturales. Estas nuevas imágenes tienen tamaños de $425\times 640$ y $374\times 353$ píxeles, respectivamente.
\subsubsection{Tiempo de Cálculo}
En la Tab. \ref{tab:timeLIPCanny} se muestran los tiempos de cálculo para cada uno de los experimentos e imágenes. En este experimento, la versión más rápida es la que aplica \emph{Canny} directamente, aunque como se ha indicado en la Sec. \ref{sec:lipCanny}, ésta no es capaz de proporcionar los contornos de las zonas en sombras. Entre las dos implementaciones que permiten la obtención de los bordes de las zonas oscuras, el método \emph{LIP--Canny} es más rápido que el mecanismo híbrido constituido por la aplicación de un \emph{Filtrado Homomórfico} seguido del algoritmo de \emph{Canny}, notado como \emph{F.H. + Canny}.
\begin{SCtable}[][!ht]
\begin{tabular}{p{0.4\textwidth}cc} \hline
\rowcolor{colorCorporativoSuave}\textsc{Tamaño} & \textsc{Método} & \textsc{Tiempo}\\
\hline\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}Canny & \cellcolor{colorCorporativoMasSuave}1.190\\
\cline{2-3}
\cellcolor{colorCorporativoMedio}$425\times 640$ & \cellcolor{colorCorporativoSuave}F.H. + Canny & \cellcolor{colorCorporativoSuave}1.341\\
\cline{2-3}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}\emph{LIP--Canny} & \cellcolor{colorCorporativoMasSuave}\textsc{1.250}\\
\hline
\cellcolor{colorCorporativoMedioSuave}  & \cellcolor{colorCorporativoSuave}Canny & \cellcolor{colorCorporativoSuave}0.519\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave}$374\times 353$ & \cellcolor{colorCorporativoMasSuave}F.H. + Canny & \cellcolor{colorCorporativoMasSuave}0.623\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}\emph{LIP--Canny} & \cellcolor{colorCorporativoSuave}\textsc{0.585}\\
\multicolumn{3}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Tiempos Canny, LIP--Canny y FH+Canny]{Tiempos de procesamiento para \emph{Canny}, \emph{LIP--Canny} y Filtrado Homomórfico (F.H.) seguido de \emph{Canny}.\label{tab:timeLIPCanny}}
\end{SCtable}
\subsubsection{Aumento del rendimiento (\emph{Speedup})}
En la Tab. \ref{tab:speedupLIPCanny} se muestra el \emph{Speedup} de cada uno de los algoritmos, tomando el \emph{LIP--Canny} como sistema de referencia para cada tamaño de imagen.
\begin{SCtable}[][!ht]
\begin{tabular}{p{0.4\textwidth}cc} \hline
\rowcolor{colorCorporativoSuave}\textsc{Tamaño} & \textsc{Método} & \textsc{Speedup}\\
\hline\hline
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}Canny & \cellcolor{colorCorporativoMasSuave}0.952\\
\cline{2-3}
\cellcolor{colorCorporativoMedio}$425\times 640$ & \cellcolor{colorCorporativoSuave}F.H. + Canny & \cellcolor{colorCorporativoSuave}1.073 \\
\cline{2-3}
\cellcolor{colorCorporativoMedio} & \cellcolor{colorCorporativoMasSuave}\emph{LIP--Canny} & \cellcolor{colorCorporativoMasSuave}\textsc{1.0} \\
\hline
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}Canny & \cellcolor{colorCorporativoSuave}0.887\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave}$374\times 353$ & \cellcolor{colorCorporativoMasSuave}F.H. + Canny & \cellcolor{colorCorporativoMasSuave}1.065\\
\cline{2-3}
\cellcolor{colorCorporativoMedioSuave} & \cellcolor{colorCorporativoSuave}\emph{LIP--Canny} & \cellcolor{colorCorporativoSuave}\textsc{1.0}\\
\multicolumn{3}{p{0.95\textwidth}}{}\vspace{-1.5em}\\
\hline
\end{tabular}
\caption[Speedup Canny, LIP--Canny y FH+Canny]{\emph{Speedup} para \emph{Canny}, \emph{LIP--Canny} y Filtrado Homomórfico (F.H.) seguido de \emph{Canny}.\label{tab:speedupLIPCanny}}
\end{SCtable}

\section{Resumen de resultados}\label{sec:resumenResultados}
\lettrine{A}{nalizando} los resultados obtenidos se puede estimar la calidad de los métodos propuestos, al menos, desde un punto de vista de eficiencia computacional y de tiempo de procesamiento. En los siguientes apartados, se van a tratar cada uno de los experimentos, calculando en cada caso el aumento de rendimiento general de cada implementación.
\subsection{LIP--Sobel}\label{sec:lipsobelResultados}
\noindent Si se toma únicamente el aspecto visual, se puede observar que el algoritmo estándar de \emph{Sobel} no es capaz de mostrar claramente los contornos de las zonas más oscuras, mientras que la implementación \emph{LIP--Sobel} sí que muestra los bordes de toda la imagen, de manera independiente al grado de iluminación local.\\
\noindent Con respecto al tiempo de procesamiento y al aumento de rendimiento, la ganancia media del experimento implementado mediante \textsc{FGLIP--Conv} es aproximadamente de $2.5$ veces más que el mismo implementado por el método de \person{Deng y Pinoli}. Mientras que, en cambio, el \emph{LIP--Sobel} utilizando el método \textsc{DGLIP--Conv} es más lento que el mismo siguiendo la propuesta de \person{Deng y Pinoli}, ya que se obtiene un \emph{Speedup} de $0.21$, es decir, es aproximadamente un $80\%$ más lento.\\
\noindent Este experimento requiere un análisis más profundo de los resultados temporales, ya que a pesar de que la versión \textsc{DGLIP--Conv} del algoritmo \emph{LIP--Sobel} utiliza un mecanismo de \emph{convolución} por filtros separables, es más lenta que la implementada mediante el mecanismo propuesto por \person{Deng y Pinoli}, que utiliza filtros bidimensionales, que haría que su aplicación fuese teóricamente más lenta. La lentitud de la propuesta \textsc{DGLIP--Conv} viene dada por dos factores: la elevada carga computacional de los operadores multiplicación y potenciación, y el hecho de que el filtro bidimensional de Sobel contiene muchos valores a $0$. Esta segunda característica hace que, para cada píxel, la aplicación del filtro bidimensional de \emph{LIP--Sobel} mediante el mecanismo propuesto por \person{Deng y Pinoli} se realice con seis multiplicaciones, una división y dos potenciaciones al cuadrado (que podrían implementarse mediante dos multiplicaciones o de manera aún más efectiva mediante un desplazamiento binario de un bit hacia la izquierda). Por tanto, tomando de manera simplificada que el tamaño de la imagen es de $n \times n$ píxeles, la aplicación de \emph{LIP--Sobel} según el método propuesto por \person{Deng y Pinoli} proporciona 18 operaciones por píxel, como muestra \eqref{eq:compLIPSobelDP}. En cualquier caso, se necesita el doble de las operaciones descritas ya que para obtener \emph{LIP--Sobel} hay que aplicar dos filtros bidimensionales para el cálculo de la imagen gradiente. Para poder proporcionar datos aún más precisos, se ha podido estimar que el operador potenciación es cinco veces más lento que el operador multiplicación, por tanto, para poder realizar comparaciones, se va a calcular el número de \emph{operaciones equivalentes} (oper. eq.) de cada implementación. La normalización en \emph{operaciones equivalentes} hace que una potenciación sea igual a 5 oper. eq. y que 1 multiplicación o división coincida con 1 oper. eq.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-Sobel}_\mathrm{Deng\& Pinoli}: \nonumber\\
&2 \times \left( n^2\times\left(6\ \mathrm{multip.} + 1\ \mathrm{divis.} + 2\ \mathrm{potenc.}\right)\right) \Rightarrow \nonumber\\
& 2\times n^2\times 9\ \mathrm{oper.} \Rightarrow 18n^2\ \mathrm{oper.} \Rightarrow 34n^2\ \mathrm{oper.\ eq.}&\label{eq:compLIPSobelDP}
\end{eqnarray}

\noindent Sin embargo, la implementación de \emph{LIP--Sobel} utilizando \textsc{DGLIP--Conv} requiere, para una imagen de igual tamaño, una doble aplicación de 3 multiplicaciones y 3 potenciaciones por filtro. En \eqref{eq:compLIPSobelDGLIPConv} se muestra la estimación del número de operaciones requeridas para dicha implementación, en la que el número de operaciones por píxel es menor que en el caso anterior, pero el número total para la imagen completa es mayor. También se indica el número de \emph{operaciones equivalentes}.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-Sobel}_\mathrm{DGLIP-Conv}: \nonumber\\
&2 \times \left( 2 \times \left(n^2\times\left(3\ \mathrm{multip.} + 3\ \mathrm{potenc.}\right)\right)\right) \Rightarrow & \nonumber\\
& 4\times n^2\times 6\ \mathrm{oper.} \Rightarrow 24n^2\ \mathrm{oper.} \Rightarrow 72n^2\ \mathrm{oper.\ eq.}&\label{eq:compLIPSobelDGLIPConv}
\end{eqnarray}

\noindent Para \textsc{DGLIP--Conv}, el cálculo utiliza un filtro en el que cada elemento del mismo tiene un valor diferente no nulo, por lo cual, no es posible realizar ninguna optimización para obtener una reducción en el número de potenciaciones (que es la operación computacionalmente más costosa). Como se podrá comprobar en otros experimentos, en cuanto los filtros que se aplican tienen un mayor tamaño y están compuestos por valores no uniformes y no nulos, la ventaja de la propuesta de \person{Deng y Pinoli} se esfuma y la implementación \textsc{DGLIP--Conv} también muestra una mejora en los tiempos de ejecución frente a dicha propuesta.
\subsection{LIP--Avg, LIP--GBlur}\label{lipavglipgblurResultados}
\noindent Como se ha comentado a lo largo del capítulo, estos dos experimentos muestran los dos extremos de \emph{caso más favorable} y \emph{más desfavorable} para el método propuesto por \person{Deng y Pinoli}. El algoritmo \emph{LIP--Avg} realiza el filtro \emph{media} y se corresponde con el ``mejor caso'', ya que se puede obtener un exponente común para todos los píxeles. Frente a este caso se encuentra el del algoritmo \emph{LIP--GBLur}, que aplica un filtrado gaussiano y es el ``peor caso'', ya que no es posible sacar un exponente común y hay que elevar cada píxel a un exponente diferente. Si se calcula el \emph{Speedup} de cada experimento, según tamaño de imagen y de filtro, de la implementación utilizando el método propuesto por \person{Deng y Pinoli} frente a las implementaciones de los mismos utilizando \textsc{DGLIP--Conv} y \textsc{FGLIP--Conv}, se puede observar que para el experimento \emph{LIP--Avg} es de $2.75$ y de $0.17$, respectivamente. Por otra parte, para el experimento \emph{LIP--GBLur} se obtiene un aumento del rendimiento de $22.62$ para \textsc{FGLIP--Conv} y de $2.06$ para \textsc{DGLIP--Conv}. Así, en general, el \emph{Speedup} medio para los dos experimentos (para todos los tamaños de imagen y de filtros) del método \textsc{FGLIP--Conv} es de $9.38$; mientras que el \emph{Speedup} medio de los experimentos implementados utilizando \textsc{DGLIP--Conv} alcanza un modesto $0.80$. Esto demuestra que la implementación mediante \textsc{FGLIP--Conv} es más rápida que el mecanismo propuesto por \person{Deng y Pinoli}, mientras que la implementación mediante \textsc{DGLIP--Conv} se comporta de forma más lenta.\\
\noindent En el experimento \emph{LIP--Avg ($3\times 3$)}, el denominado ``mejor caso'' para el mecanismo propuesto por \person{Deng y Pinoli}, se aplican 9 multiplicaciones y una potenciación (10 operaciones) por cada píxel, por lo tanto, esta implementación requiere 14 \emph{operaciones equivalentes}.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-Avg}(3\times 3)_\mathrm{Deng\& Pinoli}: \nonumber\\
&n^2\times\left(9\ \mathrm{multip.} + 1\ \mathrm{potenc.}\right) \Rightarrow 10n^2\ \mathrm{oper.} \Rightarrow 14n^2\ \mathrm{oper.\ eq.}&\nonumber \\ \label{eq:compLIPavgTresDP}
\end{eqnarray}

\noindent Por otra parte, en el método \textsc{DGLIP--Conv} se necesitan 3 multiplicaciones y 3 potenciaciones, pero hay que aplicar dos veces dicho filtrado (12 operaciones) en cada píxel, que implican 36  \emph{operaciones equivalentes}. En \eqref{eq:compLIPavgTresDP} y \eqref{eq:compLIPavgTresDGLIPConv}, se muestran respectivamente los cálculos del número de operaciones aplicadas en ambos métodos.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-Avg}(3\times 3)_\mathrm{DGLIP-Conv}: \nonumber\\
&2 \times \left( n^2\times\left(3\ \mathrm{multip.} + 3\ \mathrm{potenc.}\right)\right) \Rightarrow \nonumber\\
& 2\times n^2\times 6\ \mathrm{oper.} \Rightarrow 12n^2\ \mathrm{oper.} \Rightarrow 36n^2\ \mathrm{oper.\ eq.}&\label{eq:compLIPavgTresDGLIPConv}
\end{eqnarray}

%\noindent Para el experimento \emph{LIP--Avg ($5 \times 5$)}, la implementación propuesta por \person{Deng y Pinoli} utiliza 25 multiplicaciones y una potenciación (26 operaciones) frente a las 5 multiplicaciones y 5 potenciaciones (20 operaciones) que efectúa el método \textsc{DGLIP--Conv}. En ambos algoritmos, el método propuesto por \person{Deng y Pinoli} puede aprovechar la existencia de un factor común, que reduce el número de potenciaciones necesarias a tan sólo una. Por el contrario, \textsc{DGLIP--Conv} realiza tantas potenciaciones como elementos tienen los filtros aplicados y no puede reducir su número de operaciones. El hecho de que aplique filtros separables no consigue reducir suficientemente el tiempo de cómputo, ya que pesa mucho más el gasto computacional por el número de operaciones que ha de aplicar.\\
\noindent Por el contrario, en el último experimento \emph{LIP--GBlur}, la implementación mediante el mecanismo propuesto por \person{Deng y Pinoli} utiliza 49 multiplicaciones y 49 potenciaciones (98 operaciones) para calcular cada nuevo píxel, tal y como se muestra en \eqref{eq:compLIPgblurDP}, la cantidad de operaciones totales es de $294n^2$ \emph{operaciones equivalentes}.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-GBlur}_\mathrm{Deng\& Pinoli}: \nonumber\\
& n^2\times\left(49\ \mathrm{multip.} + 49\ \mathrm{potenc.}\right) \Rightarrow 98n^2\ \mathrm{oper.} \Rightarrow 294n^2\ \mathrm{oper.\ eq.}& \nonumber \\ \label{eq:compLIPgblurDP}
\end{eqnarray}

\noindent Mientras que para la versión que utiliza \textsc{DGLIP--Conv}, la cantidad de operaciones se reduce a 7 multiplicaciones y 7 potenciaciones por píxel y filtro. En \eqref{eq:compLIPgblurDGLIPConv} se muestra que el número de \emph{operaciones equivalentes} total es de $84n^2$.
\begin{eqnarray}
&\mathrm{Número\ de\ operaciones\ de\ LIP-GBlur}_\mathrm{DGLIP-Conv}: \nonumber\\
&2 \times \left( n^2\times\left(7\ \mathrm{multip.} + 7\ \mathrm{potenc.}\right)\right) \Rightarrow \nonumber\\
& 2\times n^2\times 14\ \mathrm{oper.} \Rightarrow 28n^2\ \mathrm{oper.} \Rightarrow 84n^2\ \mathrm{oper.\ eq.}&\label{eq:compLIPgblurDGLIPConv}
\end{eqnarray}

\noindent En este caso, el hecho de que \textsc{DGLIP--Conv} haga uso de un menor número de operaciones unido al uso de los filtros separables, tiene mayor importancia. Gracias a una mejor política de acceso (debido a un menor número de fallos de caché), esta implementación consigue batir holgadamente al método propuesto por \person{Deng y Pinoli}.
\subsection{LIP--LoG}\label{sec:liplogResultados}
\noindent Tras observar en los experimentos anteriores que \textsc{FGLIP--Conv} es el método más rápido para la implementación del operador \emph{Convolución--LIP}, para este algoritmo (\emph{LIP--LoG}) sólo se han realizado pruebas mediante el algoritmo \emph{LoG} estándar (no \textsc{LIP}), \emph{LIP--LoG} implementado mediante la técnica adaptada de la propuesta de \person{Deng y Pinoli} y \emph{LIP--LoG} implementado utilizando \textsc{FGLIP--Conv}. En general, se puede observar que \emph{LIP--LoG} es capaz de detectar bordes en zonas oscurecidas, mientras que el algoritmo \emph{LoG} estándar no es capaz de encontrar dichos contornos. Por lo que, en el aspecto temporal, aunque \emph{LoG} es el algoritmo que menos tarda, no proporciona una respuesta satisfactoria, al perderse contornos de zonas oscuras, que sí son detectados por \emph{LIP--LoG}. Particularizando en las dos implementaciones del \emph{LIP--LoG}, que son mediante el método de \person{Deng y Pinoli} y mediante \textsc{FGLIP--Conv}, se obtienen las siguientes medidas de ganancia de velocidad: \textsc{FGLIP--Conv} es aproximadamente un $60\%$ más lento que el algoritmo básico de \emph{LoG}, mientras que es entre un $200\%$ y un $350\%$ más rápido que el método propuesto por \person{Deng y Pinoli}.
\subsection{LIP--Canny}\label{lipcannyResultados}
\noindent Como ya se ha comentado en la Sec. \ref{sec:lipCanny}, el algoritmo de \emph{Canny} no es capaz de detectar contornos en las zonas oscuras ni en las sombras proyectadas, sin embargo, la implementación de \emph{LIP--Canny} realizada mediante \textsc{FGLIP--Conv} obtiene todos los contornos de los elementos de dichas zonas. Por tanto, se puede afirmar que \emph{LIP--Canny} mejora el funcionamiento general del método de \emph{Canny}.\\% y es más robusto y fácil de ajustar que si se realiza un \emph{Filtrado Homomórfico} seguido de una extracción mediante el método de \emph{Canny}.\\ % Para que el método de \emph{Canny} sea capaz de obtener resultados similares, es necesaria aplicar una fase previa de \emph{Filtrado Homomórfico}.  
\noindent Con respecto a los tiempos de cómputo, se han realizado experimentos para dos tamaños distintos (la de tamaño menor, es una imagen recortada de la mayor). El tiempo de cálculo de \emph{Canny} es aproximadamente entre un $14 \%$ y un $5 \%$ más rápido que el de \emph{LIP--Canny} y esto es debido a que para calcular \emph{LIP--Canny} se realizan una serie de operaciones adicionales, frente a la \emph{convolución} simple que se realiza en el método de \emph{Canny}. Para obtener una solución similar, a la cual no le afecten los cambios de iluminación, como se ha visto anteriormente, habrí­a que aplicar un \emph{Filtrado Homomórfico}. Esto aumenta el tiempo de cómputo con respecto a la aplicación directa del método de \emph{Canny}. Por los experimentos realizados, se ha obtenido que la aplicación de un \emph{Filtrado Homomórfico} seguido del método de \emph{Canny} es entre un $13 \%$ y $20 \%$ más lento que aplicar únicamente el método de \emph{Canny}.\\
\noindent Para este experimento, se ha calculado el \emph{Speedup} tomando como tiempo de referencia, según el tamaño de la imagen, el resultado de tiempos de la aplicación del método propuesto de \emph{LIP--Canny}. Se puede observar, que el método hí­brido (primero, \emph{Filtrado Homomórfico} y posteriormente, el método de \emph{Canny}) es entre un $6.5$ y un $7.3\%$ más lento que \emph{LIP--Canny}. Por lo tanto, también se puede afirmar que ambas implementaciones proporcionan resultados equiparables entre sí, aunque el mecanismo híbrido es más lento y el ajuste del umbral de los parámetros para dicho método es mucho más sensible a pequeñas modificaciones que en el caso de \emph{LIP--Canny}, que se comporta de forma más robusta.
\section{Conclusiones}
\lettrine{E}{n} los apartados anteriores se ha mostrado el nuevo operador propuesto (\mbox{\emph{Convolución--LIP}}), que puede ser implementado mediante dos versiones diferentes (\mbox{\textsc{DGLIP--Conv}} y \mbox{\textsc{FGLIP--Conv}}). Con ellos se ha podido observar que se puede generalizar de manera simple y efectiva cualquier algoritmo de procesamiento de imágenes al paradigma \textsc{LIP} siempre que se utilicen filtros de \emph{convolución} separables. Aunque en trabajos previos \citep{deng98}, otros autores habían dejado entrever un posible método para este fin, el operador que se propone en esta Tesis Doctoral es más versátil, puesto que permite adaptar cualquier filtro sin necesidad de recodificación.\\
\noindent Además, se han mostrado los tiempos de cómputo de los distintos experimentos. En ellos, se ha demostrado que las implementaciones de los algoritmos realizadas mediante \mbox{\textsc{FGLIP--Conv}} son las más rápidas, lográndose aumentos de velocidad (\emph{Speedup}) medias de $200\%$, es decir, el doble de rápido que otras implementaciones. En algunos experimentos se han obtenido aumentos de velocidad de más de $3600\%$.
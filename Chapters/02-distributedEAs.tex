\myChapter{Evolutionary Algorithms}\label{chap:distributedEAs} %Distributed o solo EAs? Si es distributed, ¡lo es! - JJ %FERGU: Tienes toda la razón
\minitoc\mtcskip
\vfill
%\lettrine{E}{volutionary} computation is a wide sub-field of  computational intelligence comprising several kinds of algorithms and its variants, techniques and tools \cite{eiben2003chapter1}. % en esta frase has aportado 0 bits de información. bla bla es un subcampo de bla bla que incluye bla bla - JJ


%The term \textsc{Evolutionary Algorithm} is used to describe a
%computer-based problem solving method that uses computational models
%whose design is inspired by the mechanisms of natural evolution \cite{darwin1859}. %aquí
                                %la obligatoria cita de Darwin - JJ FERGU: Done

%In this algorithms a \textsc{population} of codified solutions (called \textsc{individuals})
%They are based on a % Di esto mejor: se crea una población de
                       % soluciones codificadas...
%\textsc{population} of \textsc{individuals}, where the natural
%selection, caused by the environmental pressure, leads to an
%increase % bla bla miles de palabras que no has definido en este
         % contexto. En serio, puedes hacerlo mejor - JJ
%of the \textsc{fitness} of the individuals \cite{eiben2010whatis}. % no se incrementa el fitness de los individuos, sino de la población. El de un individuo en particular puede disminuir. No incluyas afirmaciones discutibles, y más en campos donde el tribunal sea experto - JJ
%This fitness % define donde uses por primera vez. - JJ
%is an evaluation function that describes the quality of the solution
%of the problem being solved. % sé menos descriptivo y más formas. Una
                             % función de qué conjunto a qué conjunto?
%Individuals within the population are combined and modified by means
%of \textsc{recombination} and \textsc{mutation} operators, creating
%new individuals to be added to the population. % o sea, ¿la población
                                % aumenta? Imagínate que no tienes ni
                                % idea de lo que es un algoritmos
                                % genético - JJ


%FERGU: He comentado TODO lo de arriba por lo que viene aquí.


\lettrine{E}{volutionary} Algorithms are a set of bio-inspired techniques applied to optimization problems \cite{eiben2010whatis}, based in the process of natural selection \cite{darwin1859}. In this kind of algorithms, a \textsc{population} of codified solutions (called \textsc{individuals}) is created. The most adapted individuals have more chances to be selected for reproduction, so their offspring could inherit their genetic material. The level of adaptation of each solution is measured using a \textsc{fitness} function, that usually models the problem to solve.
%FERGU: También he movido la figura del EA y pongo lo que viene a continuación:

Initially the EAs were proposed as a fixed set of steps with different operators and data structures. Then, several ways to parallelize these algorithms were also presented, with new classifications and operations. Nowadays, new emerging trends that deal with new technologies (such as P2P or Cloud Computing) and new algorithmic methods (such as parameter adaptation) are being used. These trends require a new way to develop EAs taking into account some lacks, such as integration of heterogeneous elements or dynamic resources.

In this chapter we present the classic classification of EAs to clarify their common elements, together with the most extended models to parallelize these algorithms. This classification can be used as a base for designing new algorithms, establishing their similarities. Then, the new trends in EAs are also presented to summarize their benefits, but also their lacks and problems that should be addressed. Finally, some of the most used frameworks to develop EAs are listed and analysed, to understand their capabilities and deficiencies. This way, in following chapters, the design of services for EAs will have a solid base to start.





%During the execution of the EAs, two different phases exist:
%\begin{description}
%\item[Exploration] Generation of new individuals to expand the search space. This is usually performed in the first iterations of the EA.
%\item[Explotation] Concentration in the neighbourhood of the best solutions.
%\end{description}
% No son fases. Suceden a la vez, solo que en diferentes
% proporciones. - JJ FERGU: Estaba comentado, no saldrá en la tesis.

%This chapter introduces a general overview of the most used types of Evolutionary Algorithms to clarify their common elements. Also, the most extended models to parallelize EAs are presented, to understand all their possible architectural possibilities. Finally, some of the most used frameworks to develop EAs are listed and analysed, to summarize their capabilities and lacks. This way, in following chapters, the design of services for EAs will have a solid base to start.



\section{Types of Evolutionary Algorithms}

\lettrine{T}{he} general scheme of an EA, extracted from the work of \person{Eiben and Smith} \cite{eiben2010whatis} is described in Figure \ref{fig:basicscheme}.

%hay un entorno algoritmo que hace
                                %esto mucho más chulo - JJ
                                %FERGU: sí, y lo uso en posteriores capítulos. Esto lo he copiado tal cual del libro de Eiben.

\begin{SaveVerbatim}{BasicEAtext} 
BEGIN
 INITIALISE population with random candidate solutions;
 EVALUATE each candidate;
 REPEAT UNTIL (TERMINATION CONDITION is satisfied) DO
   1 SELECT parents;
   2 RECOMBINE pairs of parents;
   3 MUTATE the resulting offspring;
   4 EVALUATE new candidates;
   3 SELECT individuals for the next generation;
 OD
END
\end{SaveVerbatim} 
%Parece COBOL. Qué vintage - JJ FERGU: Ya xD ¿Lo cambio? Ya te digo, es como viene en el libro.

\begin{SCfigure}[][!hb]
\begin{tabular}{|A|}
\hline
\BUseVerbatim{BasicEAtext}
\\
\hline
\end{tabular}
\caption{General scheme of an evolutionary algorithm in pseudo-code}
\label{fig:basicscheme}
\end{SCfigure}


Although most of the EAs follow the scheme shown in Figure
\ref{fig:basicscheme}, they have differences depending on the
representation of the solutions, the problems to solve, and other
features. A possible classification is presented in this chapter, 
taking into account the new approaches that cannot fit in traditional 
taxonomy. This classification would help to clarify the elements that 
distinguish an algorithm from another (for example, the operators), 
and the existent similarities and differences, in order to stablish 
a good starting point for designing.

\subsection{Classic classification of EAs}
This subsection explains the traditional variants, according to
the book of \person{Eiben and Smith} \cite{eiben2003introduction}. These authors clarify that the features of an EA are:
\begin{itemize}
\item EAs are population based.
\item EAs mostly uses recombination to generate new individual from the existent ones.
\item EAs are stochastic.
\end{itemize} % ¿Esto aporta algo a lo que has dicho antes? ¿A tu
              % tesis? - JJ FERGU: explicado a continuación
These are the elements that distinguish the EAs from another metaheuristics (such as the Local Search \cite{aarts1997local}, for example).

% libro que tiene 10 años y que, hoy en día, no sé si es
% vigente. Además, ¿es relevante para tu tesis? - JJ
% FERGU: La última edición es de 2010 y se sigue vendiendo y citando.
% Es relevante para entender cómo diseñar los servicios, así que 
% he añadido un párrafo arriba, he dicho que es "most of the EAs" y añado las features.

\begin{description}
\item [Genetic Algorithms] These kind of algorithms were proposed by \person{Holland} \citep{holland1975adaptation}, and also studied by \person{Goldberg} \cite{goldberg1988genetic} and \person{Michalewicz} \cite{michalewicz1996genetic}. In this kind of EA, the representation of the solution is a string of numbers (usually binary), called \textsc{chromosome} (and sometimes \textsc{genome}). The individuals are selected proportionally to their fitness, and then \textsc{recombination} and/or \textsc{mutation} are applied to generate new individuals that will be introduced in the population. These algorithms have been used in different areas, such as function optimization \cite{michalewicz1996genetic}, combinatorial optimization \cite{Esparcia2009EVITA}, artificial intelligence in videogames \cite{Fernandez20111optimizing}, or generative art \cite{Garcia2013RGB}, among others. 

\item[Evolution Strategies] The Evolution Strategies (ES) are used to solve problems whose solution is included in the domain of real numbers. Their main difference with GAs is the inclusion of self-adaptation of the mutation rate, being coded in each individual \cite{eiben2005shared}. Also, the parent selection is performed randomly. ES have been applied in fields such as Evolutionary Robotics \cite{Garcia2012testing}.

\item[Evolutionary Programming] In Evolutionary Programming (EP), the representation of the solution depends on the nature of the problem being solved, for example, neural networks \cite{Castillo1999gprop} or Radial Basis Functions (RBFs) \cite{Gonzalez2003multiobjective} have been used as individuals.

\item[Genetic Programming] The objective of this technique is to
  create functions or programs to solve determined
  problems. Individual representation is frequently in form of a tree,
  formed by operators (or {\em primitives}) and variables ({\em
    terminals}). These sets are usually fixed and known. The genome
  size is, therefore, variable, but the maximum size of the
  individuals is commonly fixed, to avoid high evaluation costs. GP has
  been used to evolve \definicion{LISP}{LISt Processing} programs
  \cite{Koza1990Tools}, or \definicion{XSLT}{eXtensible Stylesheet
    Language Transformations} scripts \cite{Garcia2008XSLT}, among
  others.

%Desde el trabajo de Michalewicz y, más todavía, las EO, se trata
%simplemente de usar diferentes estructuras de datos y operadores. No
%merece la pena que hagas esa distinción y menos hoy en día (y menos
%en tu tesis) - JJ

\end{description}

\subsection{Other models} %FERGU: TODO cambiar este nombre?

Other EAs that do not match in the previous classification  have been proposed. For example \textsc{Differential Evolution}
(DE) \cite{storn1997differential}, \textsc{Estimation of Distribution
  Algorithms} (EDAs) \cite{larranaga2002estimation} or
\textsc{Bayesian Optimization Algorithms} \cite{pelikan2005bayesian}. 
%SEGURO QUE SON EAS? 
% Por supuesto que lo son y no encajan dentro de la rígida
% clasificación anterior. Por no mencionar EAs basados en pool u otro %FERGU: añadido que no encajan
% tipo de algoritmos genéticos. Esto tienes que reescribirlo
% totalmente, suena a rancio, rancio... Además, tienes algoritmos
% evolutivos celulares, coevolutivos, meméticos y miles de cosas más
% que no encajan en una definición. No es tu tesis, pero intenta
% sintetizar las tendencias en EAs para justificar la creación de
% nuevos marcos de implementación como los de tu tesis. - JJ


%\subsection{Differential Evolution}
%Differential Evolution \cite{} also exploits a population of potential solutions. Three individuals are selected randomly from the population to create \textsc{random noisy vectors}. These vectors are recombined with original random individuals to create the \textsc{trial vectors}. These vectors are compared one by one with the original vector and the better of each comparison is kept for the next generation.

%Table \ref{tab:summaryEAs} shows the main differences between all this types of EAs. Note that we have selected the common features of each algorithm. For example, the replacement in GAs can be different from the generational one, or the representation can also be a real-value vector. 

%\begin{SCtable}[][t]
%\resizebox{11cm}{!}{
%\begin{tabular}{llllll}
%\hline
%				& Genetic algorithm 	 & Evolution Strategy  & Evolutionary Programming & Genetic Programming & Differential evolution  \\
%\hline\hline
%Representation  & Finite alphabet strings & Real-value vectors  & 					& Tree 				& Real-value vectors 	 \\
%Initialization  & \multicolumn{5}{c}{Multi-column} Random, depending of the problem and individual structure	 						 \\
%Selection 	& Fitness proportional 	& Random 				& 						& Fitness proportional & Random to create noisy vectors \\
%Recombination   & Genome crossover		& Genome crossover		& 						& Sub-tree exchange		& Random gene by gene			\\
%Mutation  		& Random 				& Gaussian perturbation	& 						& Random 				& Implicit in the noisy vectors	 \\
%Replacement		& Generational			& ($\mu,\lambda$) or ($\mu + \lambda$) &			& Generational 			& Compared with the original	 \\
%\hline
%\end{tabular}
%}
%\caption{Differences between the types of EAs.}
%\label{tab:summaryEAs}
%\end{SCtable}



Combining elements of previous algorithms with other heuristics is
the base of \textsc{Memetic Algorithms} (MAs). These algorithms are
based on the concept of {\em meme} % ¿por qué small caps y no
                                % italica? - JJ %FERGU: Tengo también que homogeneizar el formato. Usaré SC para definir nuevos conceptos, he actualizado el issue.
proposed by \person{Dawkins}
\cite{dawkins2006selfish}. In this context, a meme is domain specific knowledge coded by a computational representation to the effective solving of a problem.

This kind of algorithms can be seen as an hybrid combination of the population-based evolution methods previously explained, coupled with some kind of local search. Initially, the hybridization was made just combining two o more methods with some kind of problem knowledge. For example combining a genetic algorithm with Simulated Annealing (SA) \cite{Rodriguez2012Hybrid}. The local search can be performed before, during, or after the evaluation. New trends, such as adaptative MAs \cite{ong2006classification} lead to the usage of several memes for searching and deciding dynamically which meme to apply to each individual. For example, \person{Cowling \etal} proposed the term \textsc{hyperheuristic} \cite{cowling2001hyperheuristic} as the strategy to choose the meme to be applied depending on the time and the region of the search space (or, in a brief, heuristic to choose memes).  Other examples are the work of \person{Krasnogor \etal} \cite{krasnogor2002multimeme}, where the 
inclusion of the memetic codification inside the individual chromosome
(\textsc{Multimemes}) to select which meme to use is applied;  or
codify a set of rules, as proposed by \person{Smith} \cite{smith2002co}
(\textsc{Co-evolving MAs}).

 % y esto es interesante para tu tesis
                            % porque... (no me vale porque tengo que
                            % rellenar el capítulo de estado del arte)
                            % - JJ FERGU: Esto lo explicaba en la sección conclusiones, pero lo pongo aquí a continuación.
These kind of algorithms can be seen as a composition of other algorithms. The integration of algorithms should be as easy as possible to allow researchers develop new algorithms easily. Moreover, not only the way to combine the algorithms, but also how to dynamically select among these available algorithms. %FERGU: TODO terminar esto y dejalo más claro aún

\section{Parallel and Distributed Evolutionary Algorithms models}

\lettrine{E}{volutionary} Algorithms are inherently parallelizable, since each individual is an independent unit \cite{Alba13parallel}.

% ¿Inherentemente por qué? ¿No querrás decir trivialmente? Además, no es tan trivial porque una vez que metes esquemas de inmigración la cosa no es tan fácil: quien emigra, cuando lo hace, como se incorpora en la población... - JJ FERGU: Añaddida cita a paper que lo dice


For example, fitness evaluation can be distributed into several slave machines, % lo que sólo funciona si el trasiego es más rápido que la evaluación local, y sólo para aquellos algoritmos en los que la evaluación de un individuo sólo dependa del mismo: hay esquemas de escalado del fitness o algoritmos coevolutivos en los que esto no tiene por qué funcionar - JJ FERGU: Digo entonces que son ejemplos
or the population can be distributed among different nodes to be
evolved at the same time. In 2002, two main types of parallelization
models for EAs were classified by \person{Alba and Tomassini} in
\cite{alba2002parallelism}: \textsc{Global parallel EAs} and
\textsc{Spatially structured EAs}. However, with the aim of new
technologies and architectures, such as P2P, new ways to parallelize
EAs have been proposed. % ¿Y a quién le importa lo que pasó en 2002?
                        % Haz un esfuerzo y haz tú una clasificación
                        % en 2014 - JJ

\subsection{Traditional parallelization classification}

In this classification, issues such as fault-tolerance, churn, massive
scalability or decentralization are not taked into consideration.  % di
                                % desde el principio que esto es lo
                                % que vas a hacer - JJ
The number of computational nodes are fixed during the whole execution and both the network and the nodes are reliable and trustworthy.

\subsubsection{Global parallel evolutionary algorithms} % No sé si
                                % debería ser una subsección o
                                % simplemente un párrafo - JJ FERGUSON: es una sub-subsección, no se ve el número de subsección, no sale en los índices, y al compilar se ve bonito
In this model, also called \textsc{Farming model}, \textsc{Master-Slave} or \textsc{Centralized EA}, the parallelism is applied at evaluation level, where a central node coordinate several slave nodes. The central node executes the EA in a sequential way, but distributes the individuals of the population to the slaves just for being evaluated. Figure \ref{fig:masterslave} depicts this situation.

\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=20pc]{gfx/distributed/masterslave.jpg}
\caption{Master-slave model.}
\label{fig:masterslave}
\end{SCfigure}

\subsubsection{Spatially structured algorithms}
The parallelism is performed at population level, that is, dividing the population among the different computing elements. Depending on how the distribution is performed we have:
\begin{description}
\item[Coarse-grained approach] One of the most usual approaches is the \textsc{Island model}, where a number of nodes executes simultaneously the EA, working with different sub-populations at the same time. Each certain number of generations some individuals are interchanged (migrated) between populations. Figure \ref{fig:ring} shows this model with a ring topology.

\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=20pc]{gfx/distributed/ring.jpg}
\caption{Island model scheme using a neighbourhood ring topology.}
\label{fig:ring}
\end{SCfigure}

\item[Fine-grained approach] In this approach, also called Cellular EA (CEA), each node has one individual of the population, and selection and reproduction are limited to the individuals of the neighbourhood of the node \cite{CELLULAR}. Usually a bi-dimensional grid is used as topology, such as the one showed in the Figure \ref{fig:cellular}.

\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=5cm]{gfx/distributed/cellular.jpg}
\caption{Cellular Evolutionary Algorithm.}
\label{fig:cellular}
\end{SCfigure}

\end{description}

\subsection{New trends on parallel EAs} % ¿Por qué no convencionales?
                                % - JJ FERGU: Cambiado a new trends
Aside from the previous classification, with the advent of new
technologies, such as \textsc{cloud computing},
\definicion{P2P}{Peer-to-peer} networks, or the usage of heterogeneous
hardware, new approaches have been proposed. Distributed EAs can be
executed in other computing elements different than the classic
computers. For example, in mobile devices \cite{Garcia2009Mobile},
``smart dust'' \cite{Rollings2008smartdust} or inside robots, 
learning from the environment in an online manner \cite{Garcia2012testing}. But with
the advancement of the Internet, where millions of nodes can
co-operate, and whose behaviour is not totally controlled or
predicted, is when new distributed approaches have become more
evident.  

% ¿Esto es una clasificación? ¿A qué nivel estás clasificando? ¿Cómo
% encaja esto dentro de lo que has escrito en los primeros párrafos?
% ¿Y de TU TESIS? - JJ
\subsubsection{P2P evolutionary algorithms}

P2P systems are parallel infrastructures composed by a large number of
resources, % eso no define los sistemas P2P, sino sus
           % conexiones. Pueden tener 3 recursos. Además, ¿qué diablos
           % significa recurso en este contexto? - JJ
without any central server \cite{steinmetz2005peer}. In practice, the
resources in these networks can appear or disappear dynamically. These
platforms can be used to execute large instances of problems, taking
advantage of the massive scalability that these systems potentially
offer. %La escalabilidad no la da el sistema, sino el algoritmo. Algo
       %tan fácil como una búsqueda puede colapsar la red si el
       %algoritmo no es el correcto. Mira esto: Loo, Boon Thau, et al. "Measurement and Analysis of Ultrapeer-based P2P Search Networks." (2003).
 An example of one EA that has been designed to take advantage of these systems, is
  \definicion{EvAg}{Evolvable Agent} \cite{laredo2010evag}. This algorithm
  uses a decentralized population, where each peer has a single
 individual, and new individuals are created combining the ones in
 their current neighbours. % hala, non-sequitur. ¿Un ejemplo? ¿El más
                           % guay? ¿El más actual? ¿Soluciona qué
                           % problemas y como? - JJ FERGU: un ejemplo, y el problema que resuelve, añadido
To solve the problem of the dynamic topology, the population structure is maintained using the \textsc{newcast}
protocol \cite{jelasity2003newscast}: each node has a cache of
neighbours that can be interchanged and combined. Figure
\ref{fig:evag} shows this algorithm and its population
structure. Results show that this algorithm outperforms tuned GAs,
using less links that a panmictic (i.e. fully connected) population. % resolviendo el problema de conectividad fija (con DHT) o la introducción de nodos destacados (ultrapeers). Esto es un protocolo tipo gossip que podrías mencionar y en todo caso el primer sistema P2P de EAs no fue este, sino DREAM, de donde desciende - JJ

\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=26pc]{gfx/distributed/evag.jpg}
\caption{P2P Evolutionary Algorithm: EvAg.}
\label{fig:evag}
\end{SCfigure}

\subsubsection{Pool-based algorithms}
Other technologies % ¿cuáles? ¿Por dónde? ¿Cómo?
lead to \textsc{Pool-based EAs}, where the computational nodes
exchange individuals using a shared pool. % si son individuos para
                                % evaluar, se trata simplemente de
                                % "farming". Lo interesante es el
                                % flujo de datos de estos
                                % individuos. ¡Y cita nuestros papers
                                % y otros, como el de Gagné! - JJ
This allows massive scalability with a heterogeneous underlying
structure. This pool can be used as the global population, and the
nodes asynchronously read and evaluate the individuals. Another
possibility is that each node behaves as an island and uses the pool
to share individuals. % una posibilidad... y otra
                      % posibilidad... clasificación de tipo
                      % Borges. ¡Hay que ser exhaustivo y describir de
                      % qué se trata este tipo de algoritmo! - JJ
This can lead to automatic load-balancing and synchronization,
allowing the addition and removal of computers. % sé
                                % consistente. "computer" "node"
                                % "individual". ¿No ibas a establecer
                                % la terminología en este capítulo? - JJ
Different technologies can be used. For example, in the work of
\person{Meri \etal},  the pool used is based on the
Dropbox\texttrademark\, or SugarSync\texttrademark\ file storage
services. Other authors propose the use of non-relational databases,
such as the work of \person{Merelo \etal} \cite{merelo2010fluid},
using FluidDB\texttrademark. In \cite{merelo2012pool} the same authors
improve the design, proposing an asynchronous, fault-tolerant, and
scalable dEA, based on the object store CouchDB\texttrademark. The
results show that adding clients could not scale, but increase the
fault tolerance. Also, their experimentation shows a good methodology
for designing EAs in heterogeneous distributed systems, which have the
impossibility of analytic performance prediction. 

\subsubsection{Grid and volunteer computing} %Clasificación tipo
                                %Borges. la computación voluntaria
                                %puede ser "clásica", "basada en pool"
                                %o incluso P2P (dependiendo del
                                %cliente). 
Grids are distributed computing systems that allow sharing
geographically distributed resources to solve large scale
problems. % grid es el predecesor de la computación nube. Tampoco
          % tiene mucho que ver con la computación voluntaria, salvo
          % que se le llama "desktop grid". Sepáralos (y justifica
          % bien la clasicación real). - JJ
Several works that describe EAs being executed
% no uses "There exist" como en el chiste de Gila "Hay alguien que ha
% hecho algo malo..." - JJ FERGU: Cambiado 
in these systems have been presented \citep{grid8,grid4,grid10}. \textsc{Volunteer
  computing} \cite{anderson2005high} proposes the creation of
infrastructures to allow people donate CPU cycles for a combined
computational effort. Its main difference with grid computing is the
presence of un-trusted resources: for example, some nodes could return
intentionally wrong results, so it requires possibility of
replication. % ¿posibilidad de replicación? - JJ
Also, the control of the participating nodes is not
maintained by the experiment launcher. EAs have been used in these
systems, using several techniques, such as virtualization
\cite{Fernandez2013BOINC} or ``parasite'' computing
\cite{Merelo2007browser}. % Esta no es parásita, los participantes
                          % estaban avisados - JJ


\section{Parameter adaptation in Evolutionary Algorithms}

% y esto viene a cuento porque... - JJ

\lettrine{O}{ne} of the greater challenges of the EC field is to find
the appropriate values for EAs parameters
\cite{Eiben12Parameters}. Usually, these parameters are established by
convection or after several test runs, for example. However,
practitioners need to put effort on finding these values in order to
attain significant performance in its EAs, even taking into account
other variables, such as the computational power of the machines
used. 

\subsection{Parameter Control and Parameter Tuning}
There are two different approaches for algorithm parameter setting  in EC: {\em parameter control} and {\em parameter tuning} \cite{ParameterControlEiben99}. The first one refers to setting up a number of parameters for the Evolutionary Algorithm (EA) and changing these parameters in running time. The parameter tuning consist in establishing a good set of parameters {\em before} the run (and do not change these parameters during runtime).

Eiben, in \cite{ParameterControlEiben07} proposes the next taxonomy for the parameter control, according {\em how} are changes made:
\begin{itemize}
\item Deterministic methods: changes to a parameter are triggered by a deterministic rule (for example, increase mutation rate after certain number of generations).
\item Adaptative methods: parameters change depending on some behaviour (for example, increase mutation rate if the average fitness of the population stagnates).
\item Self-adaptative methods: parameters are encoded within the chromosome of the individuals of the population (for example, mutation rate can be a value in the chromosome).
\end{itemize}

Other classifications for control techniques in EAs are presented in that work. For example, regarding to {\em what} is changed:
\begin{itemize}
\item Representation
\item Evaluation function
\item Variation of operators and their rates
\item Selection operators
\item Replacement operator
\item Population
\end{itemize}

Finally, a third classification can be obtained according to what evidence is available:
\begin{itemize}
\item Absolute evidence: The parameter changes if a rule is activated when an specific event occurs. For example: increase mutation rate when diversity drops. In this case, human knowledge is necessary to model these rules.
\item Relative evidence: Parameters are compared with the fitness of their produced offspring and the best values are rewarded. It is not deterministic.
\end{itemize}

% Vale, llego aquí y todavía no sé qué diablos tiene que ver con los
% SOA y el OSGi y OSGILIATH - JJ

\subsection{Adaptation in heterogeneous hardware}

Adapting algorithm parameters to available computational resources
leads to improved performance (see the work of \person{Hamadi and
  Schoenauer} \cite{AutomaticallyConfiguringStyles12}). An easy way to
take advantage of the available resources is  balancing the workload
\cite{Garamendi2006Parallel} to distribute it across multiple
elements. % ¿elements, computers, individuals, nodes? - JJ
However, assigning the same tasks to each node on heterogeneous
clusters may result in suboptimal performance (as shown by
\person{Bohn and Lamont} \cite{LoadBalancingBohn02}). Parameters of an
algorithm could also be adapted to increase the performance of the
whole system. For example, the population size in EAs is the key to
obtain good performance, because it has % ¡Gramática! - JJ
 effect on the quality of the solution and the time spent during the run \cite{ShrinkageLaredo09}. This parameter has been studied as a fixed \cite{SizingHarik99} or adaptive parameter during runtime \cite{AdaptiveLobo07,SelfRegulatedSizeFernandes06}, but without taking into account the computational power of each machine in a heterogeneous cluster. 

The adaptation of an algorithm can be useful to leverage different hardware environments.
One of the problems in parameter adaptation in heterogeneous clusters is 
the representation of the computational load. It depends on the algorithm, size of the problem, programming 
language, compiler or hardware characteristics, and the results obtained from artificial 
benchmarks (such as  Linpack \cite{LinpackEndo10}) should not be extolled as identificative 
of the system performance \cite{LinpackDongarra03}. For example, in the work of \person{Garamendi 
\etal} \cite{Garamendi2006Parallel},  a small benchmark was executed in all nodes at the beginning
of the algorithm in order to distribute individuals of an Evolutionary
Strategy, following a master-slave model. % but... - JJ
The computational load by artificial benchmarks may not accurately 
 represent the correct load of the algorithm, so, information 
 about the algorithm itself should be used for calibration. % sez who?
                                % ¿Esto es tu tesis? - JJ

In other works, there is no direct relation between the algorithm parameters and 
computational resources of the nodes. % sez who again? - JJ
For example, \person{Dom\'inguez \etal} \cite{Dominguez13HydroCM} 
divided the available devices in ``faster'' and ``slower'' nodes to create a distributed hybrid 
meta-heuristic that combines two different EAs: Genetic Algorithms and Simulated
Annealing. Their system executes the heavy (in computational
terms) algorithms (GAs) in the faster nodes (computational devices), and
simpler meta-heuristics (SA) in the slower ones, obtaining better results
than other configurations.  \person{Gong \etal} in \cite{Gong2005HeterogeneousTopology} also ordered 
the nodes by their computational power to test different topology configurations in a distributed EA.
Besides  ordering the nodes taking into account 
only their previously known computational resources, the results of the previous works were not compared with executions on a homogeneous 
cluster to validate if the adaptation takes advantage of the heterogeneity 
of the cluster.

The heterogeneous computational performance of nodes or network speed can affect the performance of an algorithm. In \cite{Alba2002Heterogeneous},
 \person{Alba \etal} compared a distributed Genetic Algorithm (dGA), one of
 the sub-types of EAs, on homogeneous and heterogeneous clusters. 
 Super-linear performance in terms of iterations was obtained in the heterogeneous ones,
 being more efficient than the same algorithm running on homogeneous
 machines. However, the parameter setting was the same in both
 clusters and they did not adapt the parameters to the machines used.

 Adapting algorithm parameters to computational nodes % ahora
                                % computational nodes - JJ
derives in heterogeneous parameter sets. These sets can improve the results in homogeneous hardware, for example, setting a random set of parameters in each homogeneous node can also increase the
performance of a distributed Genetic Algorithm, as explained by \person{Gong
and Fukunaga} in \cite{Gong2011HeterogeneousParameters}. That model
outperformed a tuned canonical dGA with the same parameter values in
all islands. Also, adapting the migration rate produced better
results than homogeneous periods, as explained by \person{Salto and Alba} in
\cite{Salto2012HeterogeneousMigration}. This indicates that heterogeneous parameters
 may lead to an increase of performance, so it is necessary to validate if the 
 performance is due to the parameter set or to the heterogeneous
 devices combination. % que es lo que vamos a hacer en esta tesis. O
                      % así. - JJ


\section{Frameworks for Evolutionary Algorithms}
\lettrine{A}{} large % cada vez que dices There exist, $deity mata
                         % a un gatito - JJ FERGU: Okis, los quito todos
 number of frameworks for Evolutionary
Algorithms is freely available for download. 
% Y esto viene a cuento porque... la "narrativa" de este capítulo
% tienes que hacerla al principio del mismo, integrarlo todo en TU
% TESIS a la vez que estableces el estado del arte - JJ
Practically every
programming language has its own implementation of the basic elements
that form an EA. This implies a large effort made in each one, giving
that these elements are not compatible among them. It is also
difficult to migrate the code from a framework to another, mainly due % http://code.google.com/p/deap/
to design choices, such as the existence of hidden global variables or
language specific features (such as functional programming
\cite{Cruz2013Erlang}).  % Y migrar código es importante porque... - JJ

% di lo que es importante: genericidad, comunicación,
% prestaciones... Y evalúa cada framework con respecto a esto para
% finalmente decir que tu framework va a ser mejor, pero recuerda que
% tu tesis no es tu framework - JJ
 

\subsection{Object Oriented Frameworks}
There exist many % se está quedando sin gatitos - JJ
Object Oriented frameworks, such as Al\-go\-rithm::Evo\-lu\-tionary \cite{PERL}, \definicion{METCO}{Metaheuristic-based Extensible Tool for Collaborative Optimization} \cite{Leon2009metco},
\definicion{JCLEC}{Java Class Library for Evolutionary Computation} \cite{JCLEC} or jMetal \cite{JMETAL}. 
 Users implement specific interfaces of these frameworks ({\em
   individual} or {\em crossover}, for example) and they group them in the source
 code. For example, creating an operator object that groups several
 operators. However, these frameworks are not compatible among them.
 For example, the operators created in JCLEC can not be used in jMetal
 (despite both are programmed in Java). %Also, they can not control the
 %services (operators) outside the source code.

\subsection{Parallel frameworks} % y Borges sin
                                % animales. Algorithm::Evolutionary
                                % puede ser paralelo los paralelos
                                % orientados a objetos - JJ
Parallelism and distribution are possible in other frameworks, such as
MALLBA \citep{MALLBA}, \definicion{DREAM}{Distributed Resource
  Evolutionary Algorithm Machine} \citep{DREAM} or
\definicion{ECJ}{Evolutionary Computation in Java} \citep{ECJ}, but 
using external libraries (such as \definicion{MPI}{Message Passing Interface} or \definicion{DRM}{Distributed Resource Machine}), so the code that uses these
libraries is mixed with the algorithm's code.


 Even being distributed, these frameworks can not communicate with
 each other. %lo que es un problema por... - JJ
 HeuristicLab \citep{HEURISTICLAB} is one of the few plug-in and service oriented frameworks. It uses web services for communication, but only to distribute the load, after consulting a central database of available jobs. Finally, %the only service oriented optimization framework is
 gridUFO is a service oriented framework \citep{gridUFO}, but it only allows the modification of the objective function and the addition of whole algorithms, without combining existing services.  Table \ref{tab:frameworks} shows a summary of the previous frameworks.


\begin{SCtable}[][t]
\resizebox{11cm}{!}{
\begin{tabular}{llllll}
\hline
\rowcolor{colorCorporativoSuave}Name		&  Design 	 & Language 	& Distribution 	& License  		& Last version	\\
\hline\hline
\rowcolor{colorCorporativoMasSuave}ECJ		& OO		& Java		& Sockets   	& Academic Free Lic. 	& 2013		\\
\rowcolor{colorCorporativoSuave}MALLBA		& OO		& C++		& MPI		& Freeware		& 2010	\\
\rowcolor{colorCorporativoMasSuave}jMetal		& OO		& Java		& N/A		& GNU/LGPL 		&2013		\\
\rowcolor{colorCorporativoSuave}DREAM		& OO		& Java		& DRM		& GNU/GPL   		& 2003		\\
\rowcolor{colorCorporativoMasSuave}ParadiseEO	& OO		& C++		& MPI		& CeCILL	   	& 2012		\\
\rowcolor{colorCorporativoSuave}HeuristicLab	& OO/PO 	& .NET		& Web-Services	& GNU/GPL		& 2013			\\
\rowcolor{colorCorporativoMasSuave}METCO		& OO		& C++		& MPI		& N/A	   		& 2009	\\
\rowcolor{colorCorporativoSuave}JCLEC		& OO		& Java		& N/A		& GNU/GL   		&	2013 \\
\rowcolor{colorCorporativoMasSuave}Algorithm::Evol.& OO		& Perl		& N/A		& GNU/GPL  		& 2013	\\
\rowcolor{colorCorporativoSuave}gridUFO		&SO		& Java		& Web Services	& N/A  			& 	2010 \\
\hline
%OSGiLiath	&OO/SO/PO 	& 2010			& Java		& Distributed OSGi	& GNU/GPL  	& Lifecycle management	\\
\end{tabular}
}
\caption{Comparison of EA frameworks. OO=Object-Oriented, SO=Service Oriented, PO=Plug-in Oriented}
\label{tab:frameworks}
\end{SCtable}
% qué pasa con DEAP? - JJ http://code.google.com/p/deap/ ¿Seguro que
% no hay más?

In brief, although these frameworks follow the six criteria for genericity 
proposed by \person{Gagn{\'e} and Parizeau} in \cite{GENERICITY05}, they present some shortcomings when it is needed to develop
or add new features: the user is forced to modify the source code
or stop the execution to add new functionalities (like load balancing,
dynamic control of operators, or an user interface).


\subsection{Volunteer computing frameworks}


\definicion{BOINC}{Berkeley Open Infrastructure for Network Computing} is one of the most used frameworks in volunteer computing. This middleware follows a master-slave architecture, where the server is in charge of hosting the project experiments and the creation and distribution of jobs \cite{Fernandez2013BOINC}. Clients ask the server for works, download information, compute data and upload the results. EAs have been used in BOINC, such as the work of \person{Fern\'andez \etal} \cite{Fernandez2013BOINC}. Other authors imitate this architecture using a browser-based scheme \cite{Merelo2007browser} to distribute fitness evaluations among clients without installing any other software.

Previous systems have the possibility of task distribution among the nodes, following a master-slave model, but without interaction between clients.

\subsection{Design of EAs}
The work of \person{Gagn\'e and Parizeau} \cite{GENERICITY05} established six criteria to qualify the genericity of a framework for EAs. 

\begin{itemize}
% resalta algo, hombre - JJ
\item Generic representation: independence of the structure of the individuals. 

\item Generic fitness: Individual fitness should be as independent as possible from the selection operators and individual representation. That means that the fitness evaluation should be outside of the implementation of the individuals (for example, not implementing the fitness in the class that implements the individual). 

\item Generic operations: operations should be used in conjunction with others and have minimal side effects. For example, a multi-parent reproduction (crossover with more than two parents, as presented by \person{Eiben et al.} \cite{EibenMultiparent97}) requires separation of the concept crossover with only two elements, so the abstract concept of crossover  should accept a list of individuals. Also, new operations can be created without affect the existent ones, allowing the interaction of a non-limited number of operators. Finally, the granularity of the design of the operators must be equilibrated, not being neither too coarse (may limit the flexibility to create new operators) nor too fine (could be difficult to integrate all the operators).

\item Generic evolutionary model: As explained before, % ¿dónde? - JJ
there exist different ways to model an EA leading to different algorithms (for example, a steady-state GA versus a generational GA, or a GA versus ES). Operators should be independent of the evolutionary model, being possible the change from a model to another. 

\item Parameter management: parameters, such as the population size, may be modified during runtime. Also, a good framework must accept the addition of new parameters.

\item Configurable output: the output should be configurable. This is due to different statistics that could be used depending on the EA: for example, the tree depth in GP. Also, different outputs (console, files) should be managed.



\end{itemize}

% ¿Y ahí se queda? Una tesis no puede ser "te cuento todo esto a
% cascoporro y ya más adelante si eso te contaré por qué te lo he
% contado". Una tesis es "te voy a contar esto, te estoy contando esto
% porque te voy a contar lo otro, te estoy contando lo otro porque te
% he contado esto, y te he contado esto y lo otro". -JJ

\section {Conclusions}
\lettrine{E}{volutionary} Algorithms, and their subtypes (GAs, ES or GP, among others) follow a number of common steps: initialization, evaluation, selection, recombination, mutation, replacement and stop criterion. There exist many variations of these steps, and the different combinations can specify one algorithm or another. Memetic Algorithms also include extra elements that can be applied, and different heuristics can be combined during the algorithm's run.

Distributed EAs can improve the algorithmic and computational
performance. % over what? - JJ
 Classic parallelization approaches, such as the master-slave or island-based models, have been updated with the usage of new trends such as P2P or pool-based EAs. These new approaches manage with computational nodes entering and exiting during the experiment runtime and heterogeneous architectures.

Other research lines, such as the parameter adaptation can imply the existence of some kind of dynamism involving the parts that compose an algorithm: for example, different recombinators or mutators working at the same time. Moreover, there exist several lines of parameter adaptation in dynamic and heterogeneous environments, where different computational elements are working at the same time.

Finally, there exist a large number of different (and incompatible) frameworks for EAs, each one using different languages, technologies and communication protocols. As \person{Parejo \etal}  suggest  in \cite{SURVEYMOFS}, a standardization of the presented (and other) frameworks should be carried out. Moreover, it is difficult to access, in a public way, to available public systems to execute existent EAs to validate experiments and save time, encouraging open science.

% y todo esto es interesante para mi tesis porque... ¡No la has
% mencionado ni una vez! - JJ

Next chapter will explain a possible technological solution to address
previous issues. % which ones? Which ones are your thesis? - JJ

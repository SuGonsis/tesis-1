\myChapter{Service Oriented Architecture}\label{chap:soa}
\minitoc\mtcskip
\vfill
\lettrine{T}{he} previous chapter has explained some lacks % some
                                % lacks? algunas faltas? something
                                % lacking no es lo mismo que some
                                % lacks y no se debe usar en este
                                % contexto formal - JJ
 in the development of EAs, mainly related with the integration of
 different frameworks, distributed programming and heterogeneity of
 computational environments, among others. This chapter explains the
 concept \textsc{Service Oriented Architecture} (SOA), with several
 associated technologies and methodologies, as a possible solution for
 these issues. %Tienes que tener siempre mucho cuidado con qué
               %consideras parte de la tesis o no. Esto NO lo es pero
               %por la introducción parecía que ibas a introducir una
               %solución que no existía en el estado del
               %arte. Recuerda que tienes siempre que tener claro el
               %mapa mental de dónde encaja cada pieza dentro de la
               %TESIS y aquí no lo estás dejando. Y ten claro que la
               %tesis es TU tesis, no un review de SOA - JJ

Research in SOA \citep{Papazoglou2007SOA} is an emerging field, % si
                                % el artículo es de 2007 yo diría que
                                % ya ha terminado de emerger. - JJ
as can be seen in Figure \ref{fig:soapapers}, obtained from the search
terms {\em ``service oriented OR service-oriented''} in the Scopus
\footnote{\url{http://www.scopus.com}} database. Each year more papers
about the topic are published. This area seeks to promote services
usage and adoption, and to improve the way to use them. For example,
solving a problem combining existing services in an automatic way
\citep{Moussa2010ServiceComposition}. % Proponer una metodología
                                % porque se publica mucho equivale a
                                % decir que la vas a dejar si no se
                                % publica tanto. Es muy
                                % tricky. Deberías de pensar en algún
                                % otro mérito - JJ





\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=26pc]{gfx/soa/papersYear.png}
\caption{Number of published papers (per year) about SOA (obtained from Scopus database).}
\label{fig:soapapers}
\end{SCfigure}


Service Oriented Architecture (SOA) is a computational
paradigm where the users % users o applications? o agents? - JJ
interact with each other using the concept of
{\em service}. A service is a distributed entity (such as a node, program or
function), used to obtain a result, increasing the integration of heterogeneous
systems (several operating systems, protocols or languages) due to
this multi-platform nature. The service users do not need to know
the language used to implement the service, and they are not
forced to use a specific technology to access that service. For
example, an evolutionary algorithms researcher could have access to a
fitness function made publicly available by another researcher at the
other side of the world without even knowing which programming language
has been used to implement it. % podrías decir la relación que tiene
                               % esto con la ciencia abierta,
                               % resultados reproducibles y demás - JJ

Also, with the advancement of the Internet, new scientific
communities, based on interoperable and distributed platforms are
emerging. These communities allow scientist to collaborate on their
research, sharing data and remote access to their programs. To achieve
this, they use SOA, obtaining the benefits of the standards it
offers. Users publish and use flexible, interoperable and configurable
services. These services can be created from scratch or by leveraging
existing software. % un ejemplo!!! - JJ

\person{Foster} \cite{Foster2005Science} defines the term ``Service Oriented
Science'' as the pursuit of scientific research using distributed and
interoperable networks, being the uniformity of
these interfaces the key to success. Thanks to it, researchers can discover and access
the services without developing specific access for each data source, or
program. %ejemplos!! - JJ
Therefore, this paradigm has the potential to increase the
scientific productivity due to these public and distributed services,
and also to increase the data analysis automation in computing. There
are many examples that attempt to boost this paradigm, like Open
Science Grid \citep{Altunay2011OpenScience} and GLOBUS
\citep{Foster2005Globus}.  %citep o cite? - JJ
These projects include scientific communities and globally distributed infrastructures that support scientific and integrated applications of different domains.
It is necessary to remark that the technology for implementating services is not the
key challenge in SOA, but to increase the effort to migrate the
existing work and to change the mind of researchers and
practitioners. %to what? Esto relaciónalo con la tesis, es un capítulo
               %de TU TESIS - JJ 

\section{What is a Service?}

\lettrine{A}{} service can be seen as a function call which can be
executed locally or remotely, and which is independent of the
programming language or running platform. Services have well defined
interfaces, which depends on the desired technology to implement
SOA. That means that the service users do not need to know the
language implementation of the service or the operating system, %esto
                                %ya lo has dicho - JJ
 and they are not forced to use a specific technology to access to that service.

\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=20pc]{gfx/soa/soaDiagram.jpg}
\caption{Service interaction schema. The service provider publishes a
  service description that is used by the consumer to find and use the
  service.} % no has definido consumer todavía - JJ
\label{fig:soadiagram}
\end{SCfigure}




Figure \ref{fig:soadiagram} shows the basic interaction among
services. First, the {\em service provider} exposes the service, publishing
its interface in the {\em service broker}. The \textsc{service consumer} (or
\textsc{requestor}) finds  a service in the broker to be used and receives its
interface. Then the request is performed by the \textsc{consumer} (which uses or
consumes the service).  

According to \person{Channabasavaiah \etal} \cite{Channabasavaiah2003migrating} services must follow these  characteristics:

\begin{itemize}
\item All functions in SOA are services. This means that every
  component in SOA must be modelled as a service, or as an aggregation of services. 
\item Services are autonomous. Consumers do not need to know how the service implementation performs their function as services behave as a ``black box''.
\item Interfaces are invocable. This means that services must be
  undistinguishably local or remote, being independent of the protocol
  to establish the connection. % pasa el spell, tienes faltas de
                               % ortografía como stablish - JJ
\end{itemize}

Moreover, several implementations of a specific service  can exist (in
one or several machines). The broker can choose which one to use  each
time, or offer another if a service is temporarily
unavailable. Implementations  may also have a different behaviour, so
the researcher can take advantage to create an auto-adaptive algorithm
to select different implementations according to some criteria. % esto
                                % tenías que haberlo hecho para la
                                % tesis!!! - jj
Figure \ref{fig:servicebasic} shows this special interaction, where two different implementations of an operator interface exist (even using different languages) and the broker has chosen one of them.


The service broker in a SOA can be implemented in several ways and have
different behaviors: for example, the implementations of the services to be used can be
defined in a text file (if the services do not change in execution
time). However, the broker can also assign implementations to
interfaces in an automatic way, or using several rules, for example, in the context of EAs,
to distribute a fitness between several machines activated while the
algorithm is running. % ¿vas a hacerlo? ¿No? Trata de restringirte a
                      % lo que vas a hacer en la tesis, porque si no
                      % te preguntarán que por qué diablos no lo has
                      % hecho - JJ


\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=26pc]{gfx/soa/exampleSOA.jpg}
\caption{Example of usage of a service implementation.}
\label{fig:servicebasic}
\end{SCfigure}




An important SOA capability is that it is not focused on a specific
implementation, but offers a set of guidelines to help the
developers. In \citep{Arsanjani2008SOMA} these guidelines and good practices, and also the differences between SOA and Object Oriented
Programming (OOP) are
explained: the main difference between SOA and imperative programming or OOP is the order of service execution. This order is not necessarily static, because the services are designed to be used in a non-established and configurable order. Furthermore, another important difference is that services can be dynamically discovered and used (while in OOP a function/method must be previously known and can not change during execution), being also one of the most important capabilities the (optional) distribution in a network. Finally, in OOP the programming language must be the same for each method call.

\section{Implementation technologies}

\lettrine{D}{espite} the fact that the concept of service is independent of the technology used, there exist several ways to use and implement services, being Web Services, \definicion{ebXML}{Electronic Business XML} and \definicion{OSGi}{Open Service Gateway Initiative} the most extended.

\subsection{Web Services}

One of most popular services implementations are  \textsc{Web
  Services} \cite{Papazoglou2007SOA}. A web service is a service that
is available over Internet that uses any standardized XML (eXtended
Meta Language) \cite{XML} messaging system, and it is not tied to any
specific language or operating system \cite{Cerami2002Webservices}.
As SOA proposes, web services should be self-describing (using a
standardized grammar) and self-discoverable. % secciones de un párrafo
                                % no son secciones - JJ

\subsubsection{Messaging system} There are several alternatives to the messaging system, as SOAP or XML-RPC. SOAP (Simple Object Access Protocol) is a standard protocol proposed by the W3C \cite{SOAP}  which  extends the XML remote procedure call (XML-RPC) standard. 
It is a complete and mature protocol that allows performing remote method calls to distributed routines (services) based on an XML interface.

SOAP clients can access to objects and methods, that are residing in remote servers, using a standard mechanism that makes transparent the details of implementation, such as the programming language of the
routines, the operating system or the platform used by the provider of the service. 
At the moment, there exist complete implementations of SOAP for Perl, Java, Python, C++ and most modern languages.
Unlike other remote procedure call methods, such as RMI (\emph{remote method invocation}, used by the Java language) or XML-RPC, SOAP has two main advantages: it can be used with any programming language, and it can use any type of transport (\definicion{HTTP}{HyperText Transfer Protocol}, \definicion{SHTTP}{Secure HTTP}, \definicion{TCP}{Transmission Control Protocol}, \definicion{SMTP}{Simple Mail Transfer Protocol} and other protocols). In this way, SOAP constitutes a high level protocol, making easy the task of distributing objects among different servers, and avoiding the difficulties derived of defining the message formats, nor the explicit call to remote servers.


\subsubsection{Self-description} The interfaces of the methods that can be accessed are specified by a Web Services Description Language (WSDL) \cite{WSDL}. The WSDL of a web service consists in an XML description of its interface, i.e., it is a file that describes the name of the methods, their parameters (number and type) and their type of response.

\subsubsection{Self-discovery} UDDI ({\em Universal Description, Discovery and Integration}) \cite{UDDI} is a technical specification for describing, discovering and integrating web services \cite{Cerami2002Webservices}. This specification includes APIs for the storage and retrieval of information (also in an standardized XML format).


\subsubsection{Other standardizations} One of the advantages of using web services, is that the application stack is growing with the WS-Extensions. That is, the basic specifications of Web Services (such as SOAP) can be extended with transactions, security or messaging, for example. The most used are \cite{Papazoglou2007SOA}:
\begin{itemize}
  \item WS-Adressing  (authentication)
  \item WS-Security , WS-SecureConversation  and WS-Trust  (authorization and secure messaging)
  \item WS-Policy and WS-Metadata Exchange (policy mechanisms for interactions)
  \item WS-Reliable Messaging  and WS-Transaction (add-on mechanisms for the communication channel)
\end{itemize}

Also, functional extensions, such as WSRF \cite{WSRF}, allows the discovery, inspection and interaction with stateful resources in standard and interoperable ways. Finally, BPEL ({\em Business Process Execution Language})  \cite{BPEL} is an XML-based language to control the invocation of different Web services with added business logic to help large-scale programming.

Several studies about e-science taking advantage of web services can be found in bibliography \cite{Oinn04Taverna,davidson08workflows,Ludascher06Kepler,Perera06workflows}.

\subsection{REST}
\textsc{Representational State Transfer} (REST)\footnote{\url{http://en.wikipedia.org/wiki/Representational_state_transfer}} is an alternative method to build web services.
This technology was proposed and defined by \person{Fielding} in \cite{Fielding2002}.

In a REST-style architecture, a client sends requests to the server, who processes them and returns responses to the client.
Requests and responses represent resources that can be addressed by a Uniform resource identifier (URI). Usually, resources are documents or programs the client need to access.

REST usually works over the HTTP protocol. However it can be based on other protocols that provide the appropriate mechanisms to send requests and return responses.

In a REST environment, while servers are not concerned with the client state, clients only take care about their own state and how to address resources on the server using URIs. Moreover, clients can cache responses to improve performance.
As the client-server communication is stateless, servers are simpler and more scalable. 
Taking this into account, if the REST interface is not altered, servers and clients can be modified independently.
Finally, servers can customize the functionality of the clients by sending their logic (code) to be executed.


REST web services are simple and lightweight (as no extra XML markup is needed), their message format is readable by humans, they are easy to build, and finally, developments achieve a high performance \cite{Daigneau2011}. The main differentiating factor is that Web Services using SOAP tend to be operation-based, while REST services are resource-based.

\subsection{ebXML}
ebXML defines a set of standards that allows the enterprises negotiate their products through the Internet. It is based on a well-defined documents interchange using a contract-based approach \cite{Patil03ebxmlVsWS}, providing a specification for messaging, registry/repositories and business processes description, and unlike other approaches, it is an horizontal standard (it is not oriented towards a specific industry sector). On the contrary, Web Services expose any kind of applications to the Web, so anyone can call them (service approach). Another significant difference between Web Services and ebXML is that the former is based on BPEL, which can only describe the scenario inside a company, due to it has not all the information about the services being orchestrated, while the latter can be used to model a global choreography among several companies. Due to this, and because it is mainly focused to commercial and business processes we are not going to delve into this technology in this thesis.

\subsection{OSGi}

OSGi, was proposed by a consortium of more than
eighty companies in order to develop an infrastructure for the
deployment of services in heterogeneous network of devices, mainly
oriented to domotics \cite{GarciaSanchez2013Gateway}. Nowadays it defines a
specification for a SOA for virtual
machines (VMs). It provides very desirable features, like
packet abstraction, life-cycle management, packaging or versioning,
allowing a significant reduction of the building, support and deployment
complexity of the applications. 

OSGi technology allows dynamic discovery of new components, to increase the collaboration and to minimize and manage the coupling
among modules. Moreover, the
OSGi Alliance has developed several standard component interfaces for
common usage patterns, like HTTP servers, configuration, logs, security,
management or XML management among others, whose implementations can
be obtained by third-parties. Nowadays there are some challenges 
in the OSGi development \cite{Kriens2008OsgiChallenges}, but they only affect the creation of very complex applications.

This advantages are not so
                               costly, as can be thought: on one hand the OSGi
                                framework can be implemented in a
                                {\em jar} file\footnote{A jar file is
                                a file that groups some compiled Java
                                files.} of about 300KB, and on the other hand, and differing from
                                the normal usage of Java, each
                                class pre-charges only the other
                                classes it needs, not all. Also it is
                                non-intrusive: the code to be
                                executed in OSGi can be executed
                                without it. Finally, from its
                                specification in 1998 has been widely
                                used as base in big projects: the
                                Eclipse \definicion{IDE}{Integrated Development
                                Environment} is built over OSGi, and
                                also big application servers
                               (Glassfish\footnote{\url{http://glassfish.java.net}} 
                               or IBM Websphere \footnote{\url{http://www.ibm.com/software/websphere/}}) or
                               residential gateways
                               \cite{GarciaSanchez2013Gateway}, among other
                               examples. 



\subsubsection{Distribution}
As stated above, all services must be capable of being indistinguishable as local or remote services. Services can be distributed using the OSGi features. In this case, the distribution is performed using the service descriptor to set which service is distributable and which is the distribution technology that provides service discovering and data transmission.

OSGi allows several implementations for the service distribution. 

\section{Methodologies for developing SOA}
Regardless of the chosen SOA framework, the business processes of the platform must be analysed and modelled. So it is necessary to use a consistent and well-defined methodology to design a model based on a machine-readable description \cite{Garcia09UMM}. {\em Business-Centric Methodology (BCM) for Enterprise Agility and Interoperability} \cite{Oasis03BCM} is a roadmap for the development and implementation of procedures to create effective, efficient, and sustainable interoperability mechanisms. It has been developed by OASIS, the same consortium that created BPEL or UDDI, among others, and it is complementary to other existent architectures and technologies designed to build business oriented services, like ebXML or Web Services. BCM is formed by a set of model layers with a step-guide process, and an information pyramid to align the semantic information of partners. This allows the participation of business experts and the creation of a very large documentation repository. Nevertheless, this methodology has some disadvantages: it has a very large learning curve and it is not very extended yet. 

{\em SOMA} (Service Oriented Modelling and Architecture) \cite{Arsanjani2008SOMA} is an architecture proposed by IBM to model service oriented processes. It lets the identification, specification and implementation of services inside the SOA paradigm. To achieve this tasks, it proposes a top-down modelling oriented to intra-enterprise services (service-oriented instead of business-oriented).

{\em \definicion{UN/CEFACTs}{United Nations Center for Trade Facilitation and Electronic Business} Modelling Methodology (UMM)} \cite{Hofreiter06UMM} is an approach to model the business services that each partner must provide in order to perform a \definicion{B2B}{Business to Business} collaboration. It has a complete meta-model about business processes and business information, including a process analysis methodology. It is interesting to show that UMM provides and supports components to capture the knowledge about the business processes, and that it is independent of the underlying implementation technology (ebXML, Web Services, \definicion{CORBA}{Common Object Request Broker Architecture} or \definicion{EDI}{Electronic data interchange}). Furthermore, because UMM extends \definicion{UML}{Universal Modelling Language}, we could say that this methodology is more easily adaptable, due to the high development, acceptance and maturity of UML \cite{Garcia09UMM}. In fact, a survey of B2B modelling languages show that UMM is the most complete approach \cite{Folmer08b2b}.

\section{Benefits of using SOA in Evolutionary Algorithms Area}

\lettrine{S}{OA} has been previously used in the EA area. For example, web services have been used in the grid area for optimization problems, as can be seen in the works of \cite{grid1,grid2,grid3,grid5}, where services are defined using WSDL interfaces and other transmission mechanisms (such as Remote Procedure Call \citep{grid6,grid7}). Although there also exist EAs to be executed in grids \citep{grid8,grid4,grid10}) no information about how to design these services for EAs has been provided in previous works. 

In the previous chapter we described several lacks in the Evolutionary Algorithms area, such as the new trends of distributed programming where nodes enter and exit in runtime, or the incompatibility between frameworks, for example. All these facts motivates to create a proper way to define services for evolutionary algorithms. The elements that combine an EA are candidate to be designed as services, as they can behave as input/output functions, allowing the next issues:  

\begin{itemize}
\item Services can be combined in different ways to create the different types of EAs. The services must be designed taking into account the elements that form an EA. 
\item Services are independent of the used technology or the communication protocol. For example, a fitness service can be distributed or local.
\item Services are not aware of the order of execution, so this paradigm can fit with new parallel approaches for EAs, where nodes control is not centralized. 
\item Existent EA frameworks could also be adapted to be accessed as services.
\item SOA is the key to develop Open Science \cite{Foster2005Science}.
\end{itemize}

Even as SOA is used extensively in software development area, it is not widely accepted in the main EA software. The authors should improve their frameworks adding SOA technologies in order to facilitate the communication and integration among them. Although all the approaches described in previous chapter are focused on the implementation of distributed EAs, the abstraction level of each alternative can be quite different, as shown in Figure \ref{fig:soagrid}.  As SOA is a methodology and not a technology, areas such as Evolutionary Robotics, or EA classic frameworks can use SOA to be designed and developed. Implementation technologies, such as Web Services fill the gap between SOA (abstract) and grid (infrastructure) where interfaces are designed using SOA principles (dynamism, visibility, loose-coupling and heterogeneity). Finally, cloud computing can be seen as a combination that extends SOA adding the scalability of grid, ad suggested by \person{Jamil} \citep{SOALIB}.


\begin{SCfigure}[20][tb]
\centering
\includegraphics[width=26pc]{gfx/soa/soagrid.png}
\caption{SOA as abstract paradigm to develop in different EAs areas. Using specific technologies such as Web Services allows grid integration. This figure has been updated from the one presented in \cite{SOALIB}.}
\label{fig:soagrid}
\end{SCfigure}
We are going to use SOMA guidelines (identification, specification and realization of the services, flows and components) because is the methodology more flexible and less focused to commercial purposes. Next chapter will explain the design principles of SOA for developing services for EAs. Then, a specific SOA technology will be used to develop an implementation of a service oriented architecture for EAs.